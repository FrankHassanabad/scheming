{"version":3,"sources":["Scheming.coffee"],"names":[],"mappings":"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","file":"Scheming.js","sourceRoot":"/source/","sourcesContent":["# # Annotated Source\n\n# Support node.js or browser environments\nroot = @\n\nisNode = typeof exports != 'undefined' && typeof module != 'undefined' && module.exports\n\n# Depends on lodash\nif isNode\n  _ = require 'lodash'\nelse\n  _ = window._\n\n# Uuid generator for anonymous Schema ids\nuuid = ->\n  now = Date.now()\n  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace /[xy]/g, (c) ->\n    r = (now + Math.random() * 16) % 16 | 0\n    now = Math.floor now / 16\n    ((if c is \"x\" then r else (r & 0x7 | 0x8))).toString 16\n\n# ## Scheming\n\n# ### DEFAULT_OPTIONS\n# Default options for `Schema.create`\nDEFAULT_OPTIONS =\n  seal   : false\n  strict : false\n\n# ### TYPES\n###\n  Scheming exports the default types that it uses for parsing schemas. You can extend with custom types, or\n  override the identifier / parser functions of the default types. A custom type should provide:\n   - ctor (optional) - Used in schema definitions to declare a type. `Scheming.create name : String`\n   - string - Used in schema definitions to declare a type. `Scheming.create name : 'string'`\n   - identifier - Function, returns true or false. Determines whether a value needs to be parsed.\n   - parser - Function, parses a value into the type.\n###\nTYPES =\n  String  :\n    ctor       : String\n    string     : 'string'\n    identifier : _.isString\n    parser     : (val) ->\n      '' + val\n  Number  :\n    ctor       : Number\n    string     : 'number'\n    identifier : _.isNumber\n    parser     : parseFloat\n  Integer :\n    string     : 'integer'\n    identifier : (val) ->\n      _.isNumber(val) && val % 1 == 0\n    parser     : parseInt\n  Date    :\n    ctor       : Date\n    string     : 'date'\n    identifier : _.isDate\n    parser     : (val) ->\n      new Date val\n  Boolean :\n    ctor       : Boolean\n    string     : 'boolean'\n    identifier : _.isBoolean\n    parser     : (val) ->\n      !!val\n  Mixed   :\n    ctor       : (val) ->\n      val\n    string     : '*'\n    identifier : ->\n      true\n    parser     : _.identity\n\n# ### NESTED_TYPES\n###\n  Special type definitions for nested types. Used to identify and parse nested Arrays and Schemas.\n  Should not be extended or overridden.\n###\nNESTED_TYPES =\n  Array  :\n    ctor        : Array\n    string      : 'array'\n    identifier  : _.isArray\n    parser      : _.toArray\n    childType   : null\n    childParser : null\n  Schema :\n    ctor       : Object\n    string     : 'schema'\n    identifier : null\n    parser     : null\n    childType  : null\n\n# Used internally to resolve a type declaration to its primitive type.\n# Matches a primitive type if it is...\n# - a reference to the object straight from the `Schema.TYPES` object\n# - a reference to the `ctor`\n# - a match with the type `string` (case insensitive)\ngetPrimitiveTypeOf = (type) ->\n  for k, TYPE of TYPES\n    if type == TYPE or\n        (TYPE.ctor && type == TYPE.ctor) or\n        type?.toLowerCase?() == TYPE.string\n\n      return TYPE\n\n  return null\n\n# Expose TYPES and DEFAULT_OPTIONS for extension and overriding\nScheming = {uuid, TYPES, NESTED_TYPES, DEFAULT_OPTIONS}\n\n# ### resolveType\n# Resolves a type declaration to a primitive or nested type. Used internally when normalizing a schema.\nScheming.resolveType = (typeDef) ->\n  # - Attempt to resolve the type declaration to a primitive type\n  type = getPrimitiveTypeOf typeDef\n\n  if !type?\n    # - If the type definition is an array `[]`\n    if _.isArray typeDef\n      #   - Set the type to a clone of the array NESTED_TYPE\n      type = _.cloneDeep NESTED_TYPES.Array\n\n      #   - Recurse to resolve childType of array members\n      if typeDef.length\n        childType = Scheming.resolveType(typeDef[0])\n\n      #   - Throw an error if type is not explicitly declared\n      if !childType then throw new Error \"Error resolving type of array value #{typeDef}\"\n\n      type.childType = childType\n      #   - Write parser for child members of the array\n      type.childParser = (val) ->\n        for index, member of val\n          if !childType.identifier(member)\n            val[index] = childType.parser(member)\n\n        return val\n\n    # Function that builds identifier and parser for nested schema types. Needs to be factored out\n    # because nested schemas may be resolved lazily at a later time\n    resolveSchemaType = (type, childType) ->\n      type.childType = childType\n      type.identifier = (val) ->\n        return val instanceof childType\n      type.parser = (val) ->\n        return new childType(val)\n\n    ###\n    - If the type definition is an object `{}`\n      - Create a new Schema from the object\n      - Treat the field as a nested Schema\n      - Set identifier and parser functions immediately\n    ###\n    if _.isPlainObject typeDef\n      type = _.cloneDeep NESTED_TYPES.Schema\n      childType = Scheming.create typeDef\n      resolveSchemaType type, childType\n\n    ###\n    - If the type definition is a reference to a Schema constructor\n      - Treat the field as a nested Schema\n      - Set identifier and parser functions immediately\n    ###\n    if _.isFunction(typeDef) && typeDef.__schemaId\n      type = _.cloneDeep NESTED_TYPES.Schema\n      childType = typeDef\n      resolveSchemaType type, childType\n\n    ###\n    - If the type definition is a string that begins with Schema:, such as `'Schema:Car'`\n      - It is assumed that the field is a reference to a nested Schema that will be registered with the name Car,\n    but may not be registered yet\n      - The Schema is not resolved immediately\n      - The parser and identifier functions are written as wrappers, so that the first time they are invoked the Schema\n    will be looked up at that time via `Scheming.get`, and real identifier and parser are set at that time.\n      - If the registered Schema cannot be resolved, throw an error.\n    ###\n    if _.isString(typeDef) && typeDef[...7] == 'Schema:'\n      type = _.cloneDeep NESTED_TYPES.Schema\n      childType = typeDef[7..]\n      for fn in ['identifier', 'parser']\n        do (fn) ->\n          type[fn] = (val) ->\n            childType = Scheming.get childType\n            if !childType\n              throw new Error \"Error resolving #{typeDef} on lazy initialization\"\n            resolveSchemaType type, childType\n\n            return type[fn] val\n\n  return type || null\n\n# ### normalizePropertyConfig\n###\n  Normalizes a field declaration on a schema to capture type, default value, setter, getter, and validation.\n  Used internally when a schema is created to build a normalized schema definition.\n###\nScheming.normalizePropertyConfig = (propConfig, propName = 'field') ->\n  # initialize normalized property definition that we will return\n  definition =\n    type       : null\n    default    : null\n    getter     : null\n    setter     : null\n    validators : null\n    required   : false\n\n  # if property configuration is not an object with a type key, assume that\n  # the configuration value is just the property type\n  if !(_.isPlainObject(propConfig) && propConfig.type?)\n    propConfig = {type : propConfig}\n\n  {type, getter, setter, validate, required} = propConfig\n  # This function throws errors on any bad configuration, attempting to fail fast.\n\n\n  # - Throw an error if type is not defined. Type must always be explicitly declared. Untyped fields\n  # must explicitly declared as Schema.TYPES.Mixed\n  if !type?\n    throw new Error \"Error resolving #{propName}. Schema type must be defined.\"\n  # - Throw an error if getter is not a function\n  if getter? && !_.isFunction getter\n    throw new Error \"Error resolving #{propName}. Schema getter must be a function.\"\n  # - Throw an error if setter is not a function\n  if setter? && !_.isFunction setter\n    throw new Error \"Error resolving #{propName}. Schema setter must be a function.\"\n\n\n  validate ?= []\n  # - If validate is a single function, transform to an array with one member\n  if !_.isArray(validate)\n    validate = [validate]\n  # - Check that all validators are a function, throw an error if it is not.\n  for fn in validate\n    if !_.isFunction fn\n      throw new Error \"Error resolving #{propName}. Schema validate must be a function or array of functions.\"\n\n  # - Resolve the declared type\n  definition.type = Scheming.resolveType type\n\n  # - If type could not be resolved, throw an error\n  if !definition.type?\n    throw new Error \"Error resolving #{propName}. Unrecognized type #{type}\"\n\n  # `default` is a reserved word, so we can't do the nice clean denatured assignment\n  definition.default = propConfig.default\n  definition.getter = getter\n  definition.setter = setter\n  definition.validators = validate\n  definition.required = required\n\n  # Return a valid property configuration\n  return definition\n\n# Internal registry for schemas created by `Scheming.create`. Schemas are registered by their name, which is either\n# provided at time of creation, or generated as a uuid.\nregistry = {}\n\n# Used internally as part of `Scheming.create`, do not need to expose registration outside of Schema creation.\naddToRegistry = (key, value) ->\n  # Throw an error on naming collisions\n  if registry[key]\n    throw new Error \"Naming conflict encountered. Schema #{key} already exists\"\n  registry[key] = value\n\n# ### get\n# Retrieves a schema by registered name\nScheming.get = (name) ->\n  return registry[name]\n\n# ### reset\n# Resets the state of the Schema registry. Mainly exposed for testing, but could have use in production.\nScheming.reset = ->\n  registry = {}\n\n# ### create\n# Creates a new Schema constructor\nScheming.create = (args...) ->\n  # If the first argument is a string, then the Schema is being named & registered. Otherwise, it is being\n  # created anonymously, and we need to give it a uuid for registration.\n  if !_.isString(args[0])\n    args.unshift uuid()\n\n  # Get name, config, and options from the create arguments\n  [name, schemaConfig, opts] = args\n\n  # Set options, defaulting to the Scheming.DEFAULT_OPTIONS\n  opts = _.defaults (opts || {}), DEFAULT_OPTIONS\n\n  # Build a new Schema\n  Schema = schemaFactory(name, opts)\n\n  # Define properties on the Schema based on the schema configuration\n  Schema.defineProperties schemaConfig\n\n  # Register the new Schema by the name provided or generated\n  addToRegistry name, Schema\n\n  return Schema\n\n# ## Schema\n# Factory method that builds Schema constructors\nschemaFactory = (name, opts) ->\n  # Normalized Schema is captured in closure\n  normalizedSchema = {}\n\n  class Schema\n    # __schemaId property references the schema name and identifies Schema constructors from any other function\n    @__schemaId       : name\n\n    # ### defineProperty\n    # Defines a property on the normalized schema, which is used at time of instance construction\n    @defineProperty   : (propName, propConfig) ->\n      normalizedSchema[propName] = Scheming.normalizePropertyConfig(propConfig, propName)\n\n    # ### defineProperties\n    # Convenience method for defining properties in bulk\n    @defineProperties : (config) ->\n      for k, v of config\n        @defineProperty k, v\n\n    # ### constructor\n    # Constructor that builds instances of the Schema\n    constructor       : (model) ->\n\n      # turn `this` into a Schema instance\n      instanceFactory(@, normalizedSchema, opts)\n\n      # Finally, initialize the instance with the model passed to the constructor\n      for key, value of model\n        @[key] = value\n\n# ## Instance\n# Factory method that builds accepts an object and turns it into a Schema instance\ninstanceFactory = (instance, normalizedSchema, opts)->\n  # data hash wrapped in closure, keeps actual data members private\n  data = {}\n\n  {strict, seal} = opts\n\n  # ### constructor\n  # for each property of the normalized schema\n  for propName, propConfig of normalizedSchema\n    do (propName, propConfig) =>\n      # retrieve the type, getter, and setter from the normalized field config\n      {type, getter, setter} = propConfig\n\n      # define an enumerable property on the instance that is not configurable\n      # user get and set to manage getters, setters, and type parsing\n      Object.defineProperty instance, propName,\n        configurable : false\n        enumerable   : true\n      # **set**\n        set          : (val) ->\n          # - If a property is set to undefined, do not type cast or run through setter.\n          # You should always be able to clear a property.\n          if val is undefined\n            return data[propName] = val\n          # - If value is not undefined, run through type identifier to determine if it is the correct type\n          if !type.identifier(val)\n            #   - If not and strict mode is enabled, throw an error\n            if strict then throw new Error \"Error assigning #{val} to #{propName}. Value is not of type #{type.string}\"\n            #   - Otherwise, use parser to cast to the correct type\n            val = type.parser val\n          # - If a setter is defined, run the value through setter\n          if setter\n            val = setter val\n          # - Finally, assign to the data hash\n          data[propName] = val\n        # **get**\n        get          : ->\n          # - Retrieve data value from the hash\n          val = data[propName]\n          # - If value is not defined, immediately return it.\n          if val is undefined\n            return val\n          # - If getter is defined, run value through getter\n          if getter\n            val = getter val\n          # - If the property type is of array, perform parsing on child members now. This is costly but necessary.\n          # Because arrays can be mutated outside of assignment, we have no way to enforce parsing of child members\n          # until retrieval.\n          if type.string == NESTED_TYPES.Array.string\n            val = type.childParser val\n          # - Finally, return the value\n          return val\n\n      # Once the property is configured, assign a default value. This ensures that default values are still\n      # affected by type parsing and setters\n      if propConfig.default != undefined\n        instance[propName] = propConfig.default?() || propConfig.default\n\n  # ### validate\n  # Define a _validating flag, which is used to prevent infinite loops on validation of circular references\n  Object.defineProperty instance, '_validating',\n    writable : true\n    value : false\n\n  # Define validate method on instance\n  instance.validate = ->\n    # Create errors hash that will be returned on any validation failure.\n    errors = {}\n\n    # Flag validating state to prevent infinite loop in the case of circular references\n    if @_validating then return null\n    @_validating = true\n\n    # Factored code to push error messages onto the errors hash\n    pushError = (key, err) ->\n      if _.isArray err\n        return pushError(key, e) for e in err\n      if !_.isString err\n        err = 'Validation error occurred.'\n      errors[key] ?= []\n      errors[key].push err\n\n    # Apply validation rules\n    for key, value of normalizedSchema\n\n        {validators, required} = value\n\n        # - Retrieve value. This will be affected by getters.\n        val = @[key]\n\n        # - If the field is required and not defined, push the error and be done\n        if required && !val?\n          pushError key, \"Field is required.\"\n        # - Only run validation on fields that are defined\n        if val?\n          {type} = normalizedSchema[key]\n\n          # - Run each validator on the field value\n          for validator in validators\n            err = true\n            # - Accept error strings that are returned, or errors that are thrown during processing\n            try\n              err = validator(val)\n            catch e\n              if e then err = e.message\n            # - If any validation errors are detected, push them\n            if err != true then pushError key, err\n\n          # - Additionally, if the property is a nested schema, run its validation\n          if type.string == 'schema'\n            childErrors = val.validate()\n            for k, v of childErrors\n              #   - The key on the errors hash should be the path to the field that had a validation error\n              pushError \"#{key}.#{k}\", v\n          # - If the property is an array of schemas, run validation on each member of the array\n          if type.string == 'array' && type.childType.string == 'schema'\n            for member, i in val\n              childErrors = member.validate()\n              for k, v of childErrors\n                #   - Again, the key on the errors hash should be the path to the field that had a validation error\n                pushError \"#{key}[#{i}].#{k}\", v\n\n    # Unset flag, indicating validation is complete\n    @_validating = false\n\n    # Return null if no validation errros ocurred\n    if _.size(errors) == 0\n      return null\n    else\n      return errors\n\n  # If seal option is enabled, seal the instance, preventing addition of other properties besides those explicitly\n  # defined by the Schema\n  if seal\n    Object.seal instance\n\n# All done. Export onto the correct root.\nif isNode\n  module.exports = Scheming\nelse\n  root.Scheming = Scheming"]}