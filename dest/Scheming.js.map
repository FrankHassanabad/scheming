{"version":3,"sources":["Scheming.coffee"],"names":[],"mappings":"AAGA;AAAA,MAAA,kJAAA;IAAA,kBAAA;;AAAA,EAAA,IAAA,GAAO,IAAP,CAAA;;AAAA,EAEA,MAAA,GAAS,MAAA,CAAA,OAAA,KAAkB,WAAlB,IAAiC,MAAA,CAAA,MAAA,KAAiB,WAAlD,IAAiE,MAAM,CAAC,OAFjF,CAAA;;AAKA,EAAA,IAAG,MAAH;AACE,IAAA,CAAA,GAAI,OAAA,CAAQ,QAAR,CAAJ,CADF;GAAA,MAAA;AAGE,IAAA,CAAA,GAAI,MAAM,CAAC,CAAX,CAHF;GALA;;AAAA,EAWA,IAAA,GAAO,SAAA,GAAA;AACL,QAAA,GAAA;AAAA,IAAA,GAAA,GAAM,IAAI,CAAC,GAAL,CAAA,CAAN,CAAA;WACA,sCAAsC,CAAC,OAAvC,CAA+C,OAA/C,EAAwD,SAAC,CAAD,GAAA;AACtD,UAAA,CAAA;AAAA,MAAA,CAAA,GAAI,CAAC,GAAA,GAAM,IAAI,CAAC,MAAL,CAAA,CAAA,GAAgB,EAAvB,CAAA,GAA6B,EAA7B,GAAkC,CAAtC,CAAA;AAAA,MACA,GAAA,GAAM,IAAI,CAAC,KAAL,CAAW,GAAA,GAAM,EAAjB,CADN,CAAA;aAEC,CAAI,CAAA,KAAK,GAAR,GAAiB,CAAjB,GAAyB,CAAA,GAAI,GAAJ,GAAU,GAApC,CAA0C,CAAC,QAA5C,CAAqD,EAArD,EAHsD;IAAA,CAAxD,EAFK;EAAA,CAXP,CAAA;;AAAA,EAsBA,eAAA,GACE;AAAA,IAAA,IAAA,EAAS,KAAT;AAAA,IACA,MAAA,EAAS,KADT;GAvBF,CAAA;;AA2BA;AAAA;;;;;;;KA3BA;;AAAA,EAmCA,KAAA,GACE;AAAA,IAAA,MAAA,EACE;AAAA,MAAA,IAAA,EAAa,MAAb;AAAA,MACA,MAAA,EAAa,QADb;AAAA,MAEA,UAAA,EAAa,CAAC,CAAC,QAFf;AAAA,MAGA,MAAA,EAAa,SAAC,GAAD,GAAA;eACX,EAAA,GAAK,IADM;MAAA,CAHb;AAAA,MAKA,MAAA,EAAa,SAAC,CAAD,EAAI,CAAJ,GAAA;eAAU,CAAA,KAAG,EAAb;MAAA,CALb;KADF;AAAA,IAOA,MAAA,EACE;AAAA,MAAA,IAAA,EAAa,MAAb;AAAA,MACA,MAAA,EAAa,QADb;AAAA,MAEA,UAAA,EAAa,CAAC,CAAC,QAFf;AAAA,MAGA,MAAA,EAAa,UAHb;AAAA,MAIA,UAAA,EAAa,SAAC,CAAD,EAAI,CAAJ,GAAA;eAAU,CAAA,KAAG,EAAb;MAAA,CAJb;AAAA,MAKA,MAAA,EAAa,SAAC,CAAD,EAAI,CAAJ,GAAA;eAAU,CAAA,KAAG,EAAb;MAAA,CALb;KARF;AAAA,IAcA,OAAA,EACE;AAAA,MAAA,MAAA,EAAa,SAAb;AAAA,MACA,UAAA,EAAa,SAAC,GAAD,GAAA;eACX,CAAC,CAAC,QAAF,CAAW,GAAX,CAAA,IAAmB,GAAA,GAAM,CAAN,KAAW,EADnB;MAAA,CADb;AAAA,MAGA,MAAA,EAAa,QAHb;AAAA,MAIA,MAAA,EAAa,SAAC,CAAD,EAAI,CAAJ,GAAA;eAAU,CAAA,KAAG,EAAb;MAAA,CAJb;KAfF;AAAA,IAoBA,IAAA,EACE;AAAA,MAAA,IAAA,EAAa,IAAb;AAAA,MACA,MAAA,EAAa,MADb;AAAA,MAEA,UAAA,EAAa,CAAC,CAAC,MAFf;AAAA,MAGA,MAAA,EAAa,SAAC,GAAD,GAAA;eACP,IAAA,IAAA,CAAK,GAAL,EADO;MAAA,CAHb;AAAA,MAKA,MAAA,EAAa,SAAC,CAAD,EAAI,CAAJ,GAAA;eAAU,CAAC,CAAC,OAAF,CAAA,CAAA,KAAe,CAAC,CAAC,OAAF,CAAA,EAAzB;MAAA,CALb;KArBF;AAAA,IA2BA,OAAA,EACE;AAAA,MAAA,IAAA,EAAa,OAAb;AAAA,MACA,MAAA,EAAa,SADb;AAAA,MAEA,UAAA,EAAa,CAAC,CAAC,SAFf;AAAA,MAGA,MAAA,EAAa,SAAC,GAAD,GAAA;eACX,CAAA,CAAC,IADU;MAAA,CAHb;AAAA,MAKA,MAAA,EAAa,SAAC,CAAD,EAAI,CAAJ,GAAA;eAAU,CAAA,KAAG,EAAb;MAAA,CALb;KA5BF;AAAA,IAkCA,KAAA,EACE;AAAA,MAAA,IAAA,EAAa,SAAC,GAAD,GAAA;eACX,IADW;MAAA,CAAb;AAAA,MAEA,MAAA,EAAa,GAFb;AAAA,MAGA,UAAA,EAAa,SAAA,GAAA;eACX,KADW;MAAA,CAHb;AAAA,MAKA,MAAA,EAAa,CAAC,CAAC,QALf;AAAA,MAMA,MAAA,EAAa,SAAC,CAAD,EAAI,CAAJ,GAAA;eAAU,CAAA,KAAG,EAAb;MAAA,CANb;KAnCF;GApCF,CAAA;;AAgFA;AAAA;;;KAhFA;;AAAA,EAoFA,YAAA,GACE;AAAA,IAAA,KAAA,EACE;AAAA,MAAA,IAAA,EAAc,KAAd;AAAA,MACA,MAAA,EAAc,OADd;AAAA,MAEA,UAAA,EAAc,CAAC,CAAC,OAFhB;AAAA,MAGA,MAAA,EAAc,CAAC,CAAC,OAHhB;AAAA,MAIA,SAAA,EAAc,IAJd;AAAA,MAKA,WAAA,EAAc,IALd;AAAA,MAMA,MAAA,EAAa,SAAC,CAAD,EAAI,CAAJ,GAAA;eAAU,CAAC,CAAC,OAAF,CAAU,CAAV,EAAa,CAAb,EAAV;MAAA,CANb;KADF;AAAA,IAQA,MAAA,EACE;AAAA,MAAA,IAAA,EAAa,MAAb;AAAA,MACA,MAAA,EAAa,QADb;AAAA,MAEA,UAAA,EAAa,IAFb;AAAA,MAGA,MAAA,EAAa,IAHb;AAAA,MAIA,SAAA,EAAa,IAJb;AAAA,MAKA,MAAA,EAAa,SAAC,CAAD,EAAI,CAAJ,GAAA;eAAU,CAAA,KAAK,EAAf;MAAA,CALb;KATF;GArFF,CAAA;;AAAA,EA2GA,kBAAA,GAAqB,SAAC,IAAD,GAAA;AACnB,QAAA,OAAA;AAAA,SAAA,UAAA;sBAAA;AACE,MAAA,IAAG,IAAA,KAAQ,IAAR,IACC,CAAC,IAAI,CAAC,IAAL,IAAa,IAAA,KAAQ,IAAI,CAAC,IAA3B,CADD,6DAEC,IAAI,CAAE,gCAAN,KAAwB,IAAI,CAAC,MAFjC;AAIE,eAAO,IAAP,CAJF;OADF;AAAA,KAAA;AAOA,WAAO,IAAP,CARmB;EAAA,CA3GrB,CAAA;;AAAA,EAsHA,QAAA,GAAW;AAAA,IAAC,MAAA,IAAD;AAAA,IAAO,OAAA,KAAP;AAAA,IAAc,cAAA,YAAd;AAAA,IAA4B,iBAAA,eAA5B;GAtHX,CAAA;;AAAA,EA0HA,QAAQ,CAAC,WAAT,GAAuB,SAAC,OAAD,GAAA;AAErB,QAAA,2DAAA;AAAA,IAAA,IAAA,GAAO,kBAAA,CAAmB,OAAnB,CAAP,CAAA;AAEA,IAAA,IAAI,YAAJ;AAEE,MAAA,IAAG,CAAC,CAAC,OAAF,CAAU,OAAV,CAAH;AAEE,QAAA,IAAA,GAAO,CAAC,CAAC,SAAF,CAAY,YAAY,CAAC,KAAzB,CAAP,CAAA;AAGA,QAAA,IAAG,OAAO,CAAC,MAAX;AACE,UAAA,SAAA,GAAY,QAAQ,CAAC,WAAT,CAAqB,OAAQ,CAAA,CAAA,CAA7B,CAAZ,CADF;SAHA;AAOA,QAAA,IAAG,CAAA,SAAH;AAAmB,gBAAU,IAAA,KAAA,CAAO,sCAAA,GAAsC,OAA7C,CAAV,CAAnB;SAPA;AAAA,QASA,IAAI,CAAC,SAAL,GAAiB,SATjB,CAAA;AAAA,QAWA,IAAI,CAAC,WAAL,GAAmB,SAAC,GAAD,GAAA;AACjB,cAAA,aAAA;AAAA,eAAA,YAAA;gCAAA;AACE,YAAA,IAAG,CAAA,SAAU,CAAC,UAAV,CAAqB,MAArB,CAAJ;AACE,cAAA,GAAI,CAAA,KAAA,CAAJ,GAAa,SAAS,CAAC,MAAV,CAAiB,MAAjB,CAAb,CADF;aADF;AAAA,WAAA;AAIA,iBAAO,GAAP,CALiB;QAAA,CAXnB,CAFF;OAAA;AAAA,MAsBA,iBAAA,GAAoB,SAAC,IAAD,EAAO,SAAP,GAAA;AAClB,QAAA,IAAI,CAAC,SAAL,GAAiB,SAAjB,CAAA;AAAA,QACA,IAAI,CAAC,UAAL,GAAkB,SAAC,GAAD,GAAA;AAChB,iBAAO,GAAA,YAAe,SAAtB,CADgB;QAAA,CADlB,CAAA;eAGA,IAAI,CAAC,MAAL,GAAc,SAAC,GAAD,GAAA;AACZ,iBAAW,IAAA,SAAA,CAAU,GAAV,CAAX,CADY;QAAA,EAJI;MAAA,CAtBpB,CAAA;AA6BA;AAAA;;;;;SA7BA;AAmCA,MAAA,IAAG,CAAC,CAAC,aAAF,CAAgB,OAAhB,CAAH;AACE,QAAA,IAAA,GAAO,CAAC,CAAC,SAAF,CAAY,YAAY,CAAC,MAAzB,CAAP,CAAA;AAAA,QACA,SAAA,GAAY,QAAQ,CAAC,MAAT,CAAgB,OAAhB,CADZ,CAAA;AAAA,QAEA,iBAAA,CAAkB,IAAlB,EAAwB,SAAxB,CAFA,CADF;OAnCA;AAwCA;AAAA;;;;SAxCA;AA6CA,MAAA,IAAG,CAAC,CAAC,UAAF,CAAa,OAAb,CAAA,IAAyB,OAAO,CAAC,UAApC;AACE,QAAA,IAAA,GAAO,CAAC,CAAC,SAAF,CAAY,YAAY,CAAC,MAAzB,CAAP,CAAA;AAAA,QACA,SAAA,GAAY,OADZ,CAAA;AAAA,QAEA,iBAAA,CAAkB,IAAlB,EAAwB,SAAxB,CAFA,CADF;OA7CA;AAkDA;AAAA;;;;;;;;SAlDA;AA2DA,MAAA,IAAG,CAAC,CAAC,QAAF,CAAW,OAAX,CAAA,IAAuB,OAAQ,YAAR,KAAiB,SAA3C;AACE,QAAA,IAAA,GAAO,CAAC,CAAC,SAAF,CAAY,YAAY,CAAC,MAAzB,CAAP,CAAA;AAAA,QACA,SAAA,GAAY,OAAQ,SADpB,CAAA;AAEA;AAAA,cACK,SAAC,EAAD,GAAA;iBACD,IAAK,CAAA,EAAA,CAAL,GAAW,SAAC,GAAD,GAAA;AACT,YAAA,SAAA,GAAY,QAAQ,CAAC,GAAT,CAAa,SAAb,CAAZ,CAAA;AACA,YAAA,IAAG,CAAA,SAAH;AACE,oBAAU,IAAA,KAAA,CAAO,kBAAA,GAAkB,OAAlB,GAA0B,yBAAjC,CAAV,CADF;aADA;AAAA,YAGA,iBAAA,CAAkB,IAAlB,EAAwB,SAAxB,CAHA,CAAA;AAKA,mBAAO,IAAK,CAAA,EAAA,CAAL,CAAS,GAAT,CAAP,CANS;UAAA,EADV;QAAA,CADL;AAAA,aAAA,2CAAA;wBAAA;AACE,cAAI,GAAJ,CADF;AAAA,SAHF;OA7DF;KAFA;AA4EA,WAAO,IAAA,IAAQ,IAAf,CA9EqB;EAAA,CA1HvB,CAAA;;AA2MA;AAAA;;;KA3MA;;AAAA,EA+MA,QAAQ,CAAC,uBAAT,GAAmC,SAAC,UAAD,EAAa,QAAb,GAAA;AAEjC,QAAA,kEAAA;;MAF8C,WAAW;KAEzD;AAAA,IAAA,UAAA,GACE;AAAA,MAAA,IAAA,EAAa,IAAb;AAAA,MACA,SAAA,EAAa,IADb;AAAA,MAEA,MAAA,EAAa,IAFb;AAAA,MAGA,MAAA,EAAa,IAHb;AAAA,MAIA,QAAA,EAAa,IAJb;AAAA,MAKA,QAAA,EAAa,KALb;KADF,CAAA;AAUA,IAAA,IAAG,CAAA,CAAE,CAAC,CAAC,aAAF,CAAgB,UAAhB,CAAA,IAA+B,yBAAhC,CAAJ;AACE,MAAA,UAAA,GAAa;AAAA,QAAC,IAAA,EAAO,UAAR;OAAb,CADF;KAVA;AAAA,IAaC,kBAAA,IAAD,EAAO,oBAAA,MAAP,EAAe,oBAAA,MAAf,EAAuB,sBAAA,QAAvB,EAAiC,sBAAA,QAbjC,CAAA;AAkBA,IAAA,IAAI,YAAJ;AACE,YAAU,IAAA,KAAA,CAAO,kBAAA,GAAkB,QAAlB,GAA2B,gCAAlC,CAAV,CADF;KAlBA;AAqBA,IAAA,IAAG,gBAAA,IAAW,CAAA,CAAE,CAAC,UAAF,CAAa,MAAb,CAAf;AACE,YAAU,IAAA,KAAA,CAAO,kBAAA,GAAkB,QAAlB,GAA2B,qCAAlC,CAAV,CADF;KArBA;AAwBA,IAAA,IAAG,gBAAA,IAAW,CAAA,CAAE,CAAC,UAAF,CAAa,MAAb,CAAf;AACE,YAAU,IAAA,KAAA,CAAO,kBAAA,GAAkB,QAAlB,GAA2B,qCAAlC,CAAV,CADF;KAxBA;;MA2BA,WAAY;KA3BZ;AA6BA,IAAA,IAAG,CAAA,CAAE,CAAC,OAAF,CAAU,QAAV,CAAJ;AACE,MAAA,QAAA,GAAW,CAAC,QAAD,CAAX,CADF;KA7BA;AAgCA,SAAA,+CAAA;wBAAA;AACE,MAAA,IAAG,CAAA,CAAE,CAAC,UAAF,CAAa,EAAb,CAAJ;AACE,cAAU,IAAA,KAAA,CAAO,kBAAA,GAAkB,QAAlB,GAA2B,6DAAlC,CAAV,CADF;OADF;AAAA,KAhCA;AAAA,IAqCA,UAAU,CAAC,IAAX,GAAkB,QAAQ,CAAC,WAAT,CAAqB,IAArB,CArClB,CAAA;AAwCA,IAAA,IAAI,uBAAJ;AACE,YAAU,IAAA,KAAA,CAAO,kBAAA,GAAkB,QAAlB,GAA2B,sBAA3B,GAAiD,IAAxD,CAAV,CADF;KAxCA;AAAA,IA4CA,UAAU,CAAC,SAAD,CAAV,GAAqB,UAAU,CAAC,SAAD,CA5C/B,CAAA;AAAA,IA6CA,UAAU,CAAC,MAAX,GAAoB,MA7CpB,CAAA;AAAA,IA8CA,UAAU,CAAC,MAAX,GAAoB,MA9CpB,CAAA;AAAA,IA+CA,UAAU,CAAC,QAAX,GAAsB,QA/CtB,CAAA;AAAA,IAgDA,UAAU,CAAC,QAAX,GAAsB,QAhDtB,CAAA;AAAA,IAmDA,UAAA,GAAa,CAAC,CAAC,MAAF,CAAS,EAAT,EAAa,UAAb,EAAyB,UAAzB,CAnDb,CAAA;AAsDA,WAAO,UAAP,CAxDiC;EAAA,CA/MnC,CAAA;;AAAA,EA2QA,QAAA,GAAW,EA3QX,CAAA;;AAAA,EA8QA,aAAA,GAAgB,SAAC,GAAD,EAAM,KAAN,GAAA;AAEd,IAAA,IAAG,QAAS,CAAA,GAAA,CAAZ;AACE,YAAU,IAAA,KAAA,CAAO,sCAAA,GAAsC,GAAtC,GAA0C,iBAAjD,CAAV,CADF;KAAA;WAEA,QAAS,CAAA,GAAA,CAAT,GAAgB,MAJF;EAAA,CA9QhB,CAAA;;AAAA,EAsRA,QAAQ,CAAC,GAAT,GAAe,SAAC,IAAD,GAAA;AACb,WAAO,QAAS,CAAA,IAAA,CAAhB,CADa;EAAA,CAtRf,CAAA;;AAAA,EA2RA,QAAQ,CAAC,KAAT,GAAiB,SAAA,GAAA;WACf,QAAA,GAAW,GADI;EAAA,CA3RjB,CAAA;;AAAA,EAgSA,QAAQ,CAAC,MAAT,GAAkB,SAAA,GAAA;AAGhB,QAAA,sCAAA;AAAA,IAHiB,8DAGjB,CAAA;AAAA,IAAA,IAAG,CAAA,CAAE,CAAC,QAAF,CAAW,IAAK,CAAA,CAAA,CAAhB,CAAJ;AACE,MAAA,IAAI,CAAC,OAAL,CAAa,IAAA,CAAA,CAAb,CAAA,CADF;KAAA;AAAA,IAIC,cAAD,EAAO,sBAAP,EAAqB,cAJrB,CAAA;AAAA,IAOA,IAAA,GAAO,CAAC,CAAC,QAAF,CAAY,IAAA,IAAQ,EAApB,EAAyB,eAAzB,CAPP,CAAA;AAAA,IAUA,MAAA,GAAS,aAAA,CAAc,IAAd,EAAoB,IAApB,CAVT,CAAA;AAAA,IAaA,MAAM,CAAC,gBAAP,CAAwB,YAAxB,CAbA,CAAA;AAAA,IAgBA,aAAA,CAAc,IAAd,EAAoB,MAApB,CAhBA,CAAA;AAkBA,WAAO,MAAP,CArBgB;EAAA,CAhSlB,CAAA;;AAAA,EAyTA,aAAA,GAAgB,SAAC,IAAD,EAAO,IAAP,GAAA;AAEd,QAAA,wBAAA;AAAA,IAAA,gBAAA,GAAmB,EAAnB,CAAA;WAEM;AAEJ,MAAA,MAAC,CAAA,UAAD,GAAoB,IAApB,CAAA;;AAAA,MAIA,MAAC,CAAA,cAAD,GAAoB,SAAC,QAAD,EAAW,UAAX,GAAA;eAClB,gBAAiB,CAAA,QAAA,CAAjB,GAA6B,QAAQ,CAAC,uBAAT,CAAiC,UAAjC,EAA6C,QAA7C,EADX;MAAA,CAJpB,CAAA;;AAAA,MASA,MAAC,CAAA,gBAAD,GAAoB,SAAC,MAAD,GAAA;AAClB,YAAA,cAAA;AAAA;aAAA,WAAA;wBAAA;AACE,wBAAA,IAAC,CAAA,cAAD,CAAgB,CAAhB,EAAmB,CAAnB,EAAA,CADF;AAAA;wBADkB;MAAA,CATpB,CAAA;;AAAA,MAeA,MAAC,CAAA,aAAD,GAAiB,SAAA,GAAA;AACf,eAAO,CAAC,CAAC,SAAF,CAAY,gBAAZ,CAAP,CADe;MAAA,CAfjB,CAAA;;AAAA,MAoBA,MAAC,CAAA,WAAD,GAAe,SAAC,QAAD,GAAA;AACb,eAAO,CAAC,CAAC,SAAF,CAAY,gBAAiB,CAAA,QAAA,CAA7B,CAAP,CADa;MAAA,CApBf,CAAA;;AAAA,MAyBA,MAAC,CAAA,YAAD,GAAgB,SAAC,EAAD,GAAA;AACd,YAAA,8BAAA;AAAA;aAAA,4BAAA;kDAAA;AACE,wBAAA,EAAA,CAAG,QAAH,EAAa,CAAC,CAAC,SAAF,CAAY,UAAZ,CAAb,EAAA,CADF;AAAA;wBADc;MAAA,CAzBhB,CAAA;;AAAA,MA+BA,MAAC,CAAA,QAAD,GAAY,SAAC,QAAD,GAAA;AAEV,YAAA,kIAAA;AAAA,QAAA,MAAA,GAAS,EAAT,CAAA;AAGA,QAAA,IAAG,QAAQ,CAAC,WAAZ;AAA6B,iBAAO,IAAP,CAA7B;SAHA;AAAA,QAIA,QAAQ,CAAC,WAAT,GAAuB,IAJvB,CAAA;AAAA,QAOA,SAAA,GAAY,SAAC,GAAD,EAAM,GAAN,GAAA;AACV,cAAA,WAAA;AAAA,UAAA,IAAG,CAAC,CAAC,OAAF,CAAU,GAAV,CAAH;AACE,iBAAA,0CAAA;0BAAA;AAAA,qBAAO,SAAA,CAAU,GAAV,EAAe,CAAf,CAAP,CAAA;AAAA,aADF;WAAA;AAEA,UAAA,IAAG,CAAA,CAAE,CAAC,QAAF,CAAW,GAAX,CAAJ;AACE,YAAA,GAAA,GAAM,4BAAN,CADF;WAFA;;YAIA,MAAO,CAAA,GAAA,IAAQ;WAJf;iBAKA,MAAO,CAAA,GAAA,CAAI,CAAC,IAAZ,CAAiB,GAAjB,EANU;QAAA,CAPZ,CAAA;AAgBA,aAAA,uBAAA;wCAAA;AACE,UAAC,iBAAA,QAAD,EAAW,iBAAA,QAAX,CAAA;AAAA,UAGA,GAAA,GAAM,QAAS,CAAA,GAAA,CAHf,CAAA;AAMA,UAAA,IAAG,QAAA,IAAa,aAAhB;AACE,YAAA,SAAA,CAAU,GAAV,EAAe,oBAAf,CAAA,CADF;WANA;AASA,UAAA,IAAG,WAAH;AACE,YAAC,OAAQ,gBAAiB,CAAA,GAAA,EAAzB,IAAD,CAAA;AAGA,iBAAA,+CAAA;uCAAA;AACE,cAAA,GAAA,GAAM,IAAN,CAAA;AAEA;AACE,gBAAA,GAAA,GAAM,SAAA,CAAU,GAAV,CAAN,CADF;eAAA,cAAA;AAGE,gBADI,UACJ,CAAA;AAAA,gBAAA,IAAG,CAAH;AAAU,kBAAA,GAAA,GAAM,CAAC,CAAC,OAAR,CAAV;iBAHF;eAFA;AAOA,cAAA,IAAG,GAAA,KAAO,IAAV;AAAoB,gBAAA,SAAA,CAAU,GAAV,EAAe,GAAf,CAAA,CAApB;eARF;AAAA,aAHA;AAcA,YAAA,IAAG,IAAI,CAAC,MAAL,KAAe,QAAlB;AACE,cAAA,WAAA,GAAc,IAAI,CAAC,SAAS,CAAC,QAAf,CAAwB,GAAxB,CAAd,CAAA;AACA,mBAAA,gBAAA;mCAAA;AAEE,gBAAA,SAAA,CAAU,EAAA,GAAG,GAAH,GAAO,GAAP,GAAU,CAApB,EAAyB,CAAzB,CAAA,CAFF;AAAA,eAFF;aAdA;AAoBA,YAAA,IAAG,IAAI,CAAC,MAAL,KAAe,OAAf,IAA0B,IAAI,CAAC,SAAS,CAAC,MAAf,KAAyB,QAAtD;AACE,mBAAA,oDAAA;gCAAA;AACE,gBAAA,WAAA,GAAc,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,QAAzB,CAAkC,MAAlC,CAAd,CAAA;AACA,qBAAA,gBAAA;qCAAA;AAEE,kBAAA,SAAA,CAAU,EAAA,GAAG,GAAH,GAAO,GAAP,GAAU,CAAV,GAAY,IAAZ,GAAgB,CAA1B,EAA+B,CAA/B,CAAA,CAFF;AAAA,iBAFF;AAAA,eADF;aArBF;WAVF;AAAA,SAhBA;AAAA,QAuDA,QAAQ,CAAC,WAAT,GAAuB,KAvDvB,CAAA;AA0DA,QAAA,IAAG,CAAC,CAAC,IAAF,CAAO,MAAP,CAAA,KAAkB,CAArB;AACE,iBAAO,IAAP,CADF;SAAA,MAAA;AAGE,iBAAO,MAAP,CAHF;SA5DU;MAAA,CA/BZ,CAAA;;AAAA,MAkGA,MAAC,CAAA,KAAD,GAAS,SAAC,QAAD,EAAW,UAAX,EAAuB,EAAvB,GAAA;eACP,QAAQ,CAAC,WAAT,CAAqB,UAArB,EAAiC,EAAjC,EADO;MAAA,CAlGT,CAAA;;AAuGoB,MAAA,gBAAC,KAAD,GAAA;AAGlB,QAAA,eAAA,CAAgB,IAAhB,EAAmB,gBAAnB,EAAqC,IAArC,CAAA,CAAA;AAAA,QAGA,IAAC,CAAA,GAAD,CAAK,KAAL,CAHA,CAHkB;MAAA,CAvGpB;;oBAAA;;SANY;EAAA,CAzThB,CAAA;;AAAA,EAgbA,eAAA,GAAkB,SAAC,QAAD,EAAW,gBAAX,EAA6B,IAA7B,GAAA;AAEhB,QAAA,6CAAA;AAAA,IAAA,IAAA,GAAO,EAAP,CAAA;AAAA,IAEC,cAAA,MAAD,EAAS,YAAA,IAFT,CAAA;AAAA,IAIA,MAAM,CAAC,cAAP,CAAsB,QAAtB,EAAgC,KAAhC,EACE;AAAA,MAAA,YAAA,EAAe,KAAf;AAAA,MACA,UAAA,EAAa,KADb;AAAA,MAEA,QAAA,EAAW,KAFX;AAAA,MAGA,KAAA,EAAQ,SAAC,QAAD,EAAW,GAAX,GAAA;AACN,YAAA,0CAAA;AAAA,QAAA,QAAA,GAAW,EAAX,CAAA;AAAA,QACA,GAAA,GAAM,EADN,CAAA;AAGA,QAAA,IAAG,SAAS,CAAC,MAAV,KAAoB,CAAvB;AACE,UAAA,GAAI,CAAA,QAAA,CAAJ,GAAgB,GAAhB,CADF;SAAA,MAAA;AAGE,UAAA,GAAA,GAAM,QAAN,CAHF;SAHA;AAQA,aAAA,eAAA;8BAAA;AACE,UAAA,OAAA,GAAU,IAAK,CAAA,QAAA,CAAf,CAAA;AAIA,UAAA,IAAG,CAAA,gBAAkB,CAAA,QAAA,CAArB;AACE,mBAAO,QAAS,CAAA,QAAA,CAAT,GAAqB,GAA5B,CADF;WAJA;AAAA,UAQA,OAAiB,gBAAiB,CAAA,QAAA,CAAlC,EAAC,YAAA,IAAD,EAAO,cAAA,MARP,CAAA;AAYA,UAAA,IAAG,GAAA,KAAO,MAAV;AACE,YAAA,IAAK,CAAA,QAAA,CAAL,GAAiB,GAAjB,CADF;WAAA,MAAA;AAIE,YAAA,IAAG,CAAA,IAAK,CAAC,UAAL,CAAgB,GAAhB,CAAJ;AAEE,cAAA,IAAG,MAAH;AAAe,sBAAU,IAAA,KAAA,CAAO,kBAAA,GAAkB,GAAlB,GAAsB,MAAtB,GAA4B,QAA5B,GAAqC,yBAArC,GAA8D,IAAI,CAAC,MAA1E,CAAV,CAAf;eAAA;AAAA,cAEA,GAAA,GAAM,IAAI,CAAC,MAAL,CAAY,GAAZ,CAFN,CAFF;aAAA;AAMA,YAAA,IAAG,IAAI,CAAC,MAAL,KAAe,YAAY,CAAC,KAAK,CAAC,MAArC;AACE,cAAA,GAAA,GAAM,IAAI,CAAC,WAAL,CAAiB,GAAjB,CAAN,CADF;aANA;AASA,YAAA,IAAG,MAAH;AACE,cAAA,GAAA,GAAM,MAAA,CAAO,GAAP,CAAN,CADF;aATA;AAAA,YAYA,IAAK,CAAA,QAAA,CAAL,GAAiB,GAZjB,CAAA;AAcA,YAAA,IAAG,CAAA,IAAK,CAAC,MAAL,CAAY,OAAZ,EAAqB,GAArB,CAAJ;AACE,cAAA,QAAS,CAAA,QAAA,CAAT,GAAqB,OAArB,CADF;aAlBF;WAbF;AAAA,SARA;eA0CA,IAAC,CAAA,aAAD,CAAe,QAAf,EA3CM;MAAA,CAHR;KADF,CAJA,CAAA;AAAA,IAqDA,MAAM,CAAC,cAAP,CAAsB,QAAtB,EAAgC,KAAhC,EACE;AAAA,MAAA,YAAA,EAAe,KAAf;AAAA,MACA,UAAA,EAAa,KADb;AAAA,MAEA,QAAA,EAAW,KAFX;AAAA,MAGA,KAAA,EAAQ,SAAC,QAAD,GAAA;AAEN,YAAA,uBAAA;AAAA,QAAA,OAAiB,gBAAiB,CAAA,QAAA,CAAlC,EAAC,YAAA,IAAD,EAAO,cAAA,MAAP,CAAA;AAAA,QAGA,GAAA,GAAM,IAAK,CAAA,QAAA,CAHX,CAAA;AAKA,QAAA,IAAG,GAAA,KAAO,MAAV;AACE,iBAAO,GAAP,CADF;SALA;AAQA,QAAA,IAAO,IAAI,CAAC,MAAL,KAAe,QAAtB;AACE,UAAA,GAAA,GAAM,CAAC,CAAC,KAAF,CAAQ,GAAR,CAAN,CADF;SARA;AAWA,QAAA,IAAG,MAAH;AACE,UAAA,GAAA,GAAM,MAAA,CAAO,GAAP,CAAN,CADF;SAXA;AAcA,eAAO,GAAP,CAhBM;MAAA,CAHR;KADF,CArDA,CAAA;AAAA,IA4EA,MAAM,CAAC,cAAP,CAAsB,QAAtB,EAAgC,aAAhC,EACE;AAAA,MAAA,YAAA,EAAe,KAAf;AAAA,MACA,UAAA,EAAa,KADb;AAAA,MAEA,QAAA,EAAW,IAFX;AAAA,MAGA,KAAA,EAAQ,KAHR;KADF,CA5EA,CAAA;AAAA,IAmFA,MAAM,CAAC,cAAP,CAAsB,QAAtB,EAAgC,WAAhC,EACE;AAAA,MAAA,YAAA,EAAe,KAAf;AAAA,MACA,UAAA,EAAa,KADb;AAAA,MAEA,QAAA,EAAW,IAFX;AAAA,MAGA,KAAA,EAAQ,EAHR;KADF,CAnFA,CAAA;AAAA,IAyFA,MAAM,CAAC,cAAP,CAAsB,QAAtB,EAAgC,aAAhC,EACE;AAAA,MAAA,YAAA,EAAe,KAAf;AAAA,MACA,UAAA,EAAa,KADb;AAAA,MAEA,QAAA,EAAW,IAFX;AAAA,MAGA,KAAA,EAAQ,SAAC,UAAD,EAAa,EAAb,GAAA;AACN,YAAA,oCAAA;AAAA,QAAA,IAAG,CAAC,CAAC,UAAF,CAAa,UAAb,CAAH;AACE,UAAA,EAAA,GAAK,UAAL,CAAA;AAAA,UACA,UAAA,GAAa,CAAC,CAAC,IAAF,CAAO,gBAAP,CADb,CADF;SAAA;AAIA,QAAA,IAAG,CAAA,CAAE,CAAC,UAAF,CAAa,EAAb,CAAJ;AACE,gBAAU,IAAA,KAAA,CAAM,oDAAN,CAAV,CADF;SAJA;AAOA,QAAA,IAAG,UAAA,IAAc,CAAA,CAAE,CAAC,OAAF,CAAU,UAAV,CAAlB;AACE,UAAA,UAAA,GAAa,CAAC,UAAD,CAAb,CADF;SAPA;AAAA,QAUA,OAAA,GAAU,EAVV,CAAA;AAWA,aAAA,iDAAA;oCAAA;AACE,UAAA,IAAG,CAAA,CAAE,CAAC,GAAF,CAAM,gBAAN,EAAwB,QAAxB,CAAJ;AACE,kBAAU,IAAA,KAAA,CAAO,sBAAA,GAAsB,QAAtB,GAA+B,sCAAtC,CAAV,CADF;WAAA;AAAA,UAEA,OAAQ,CAAA,QAAA,CAAR,GAAoB,QAAS,CAAA,QAAA,CAF7B,CADF;AAAA,SAXA;AAeA,QAAA,IAAG,UAAU,CAAC,MAAX,KAAqB,CAAxB;AACE,UAAA,OAAA,GAAU,OAAQ,CAAA,QAAA,CAAlB,CADF;SAfA;AAAA,QAkBA,EAAA,CAAG,OAAH,EAAY,OAAZ,CAlBA,CAAA;AAAA,QAoBA,OAAA,GAAU;AAAA,UAAC,YAAA,UAAD;AAAA,UAAa,IAAA,EAAb;SApBV,CAAA;AAAA,QAqBA,QAAQ,CAAC,SAAS,CAAC,IAAnB,CAAwB,OAAxB,CArBA,CAAA;AAwBA,eAAO,SAAA,GAAA;iBACL,QAAQ,CAAC,cAAT,CAAwB,OAAxB,EADK;QAAA,CAAP,CAzBM;MAAA,CAHR;KADF,CAzFA,CAAA;AAAA,IAyHA,MAAM,CAAC,cAAP,CAAsB,QAAtB,EAAgC,gBAAhC,EACE;AAAA,MAAA,YAAA,EAAe,KAAf;AAAA,MACA,UAAA,EAAa,KADb;AAAA,MAEA,QAAA,EAAW,IAFX;AAAA,MAGA,KAAA,EAAQ,SAAC,OAAD,GAAA;eACN,CAAC,CAAC,MAAF,CAAS,QAAQ,CAAC,SAAlB,EAA6B,OAA7B,EADM;MAAA,CAHR;KADF,CAzHA,CAAA;AAAA,IAgIA,MAAM,CAAC,cAAP,CAAsB,QAAtB,EAAgC,eAAhC,EACE;AAAA,MAAA,YAAA,EAAe,KAAf;AAAA,MACA,UAAA,EAAa,KADb;AAAA,MAEA,QAAA,EAAW,IAFX;AAAA,MAGA,KAAA,EAAQ,SAAC,QAAD,GAAA;AACN,YAAA,oJAAA;AAAA,QAAA,oBAAA,GAAuB,CAAC,CAAC,IAAF,CAAO,QAAP,CAAvB,CAAA;AAAA,QAEA,MAAA,GAAS,EAFT,CAAA;AAAA,QAGA,aAAA,GAAgB,SAAC,QAAD,GAAA;AACd,cAAA,GAAA;AAAA,UAAA,IAAG,MAAO,CAAA,QAAA,CAAV;AACE,mBAAO,MAAO,CAAA,QAAA,CAAd,CADF;WAAA,MAAA;AAGE,YAAA,GAAA,GAAM,QAAS,CAAA,QAAA,CAAf,CAAA;AAAA,YACA,MAAO,CAAA,QAAA,CAAP,GAAmB,GADnB,CAAA;AAEA,mBAAO,GAAP,CALF;WADc;QAAA,CAHhB,CAAA;AAAA,QAUA,UAAA,GAAa,SAAC,QAAD,GAAA;AACX,UAAA,IAAG,CAAC,CAAC,GAAF,CAAM,QAAN,EAAgB,QAAhB,CAAH;AACE,mBAAO,QAAS,CAAA,QAAA,CAAhB,CADF;WAAA,MAAA;AAGE,mBAAO,aAAA,CAAc,QAAd,CAAP,CAHF;WADW;QAAA,CAVb,CAAA;AAgBA;AAAA;aAAA,2CAAA;6BAAA;AACE,UAAA,UAAA,GAAa,CAAC,CAAC,YAAF,CAAe,oBAAf,EAAqC,OAAO,CAAC,UAA7C,CAAwD,CAAC,MAAzD,GAAkE,CAA/E,CAAA;AACA,UAAA,IAAG,UAAH;AACE,YAAA,OAAA,GAAU,EAAV,CAAA;AAAA,YACA,OAAA,GAAU,EADV,CAAA;AAGA;AAAA,iBAAA,8CAAA;mCAAA;AACE,cAAA,OAAQ,CAAA,QAAA,CAAR,GAAoB,aAAA,CAAc,QAAd,CAApB,CAAA;AAAA,cACA,OAAQ,CAAA,QAAA,CAAR,GAAoB,UAAA,CAAW,QAAX,CADpB,CADF;AAAA,aAHA;AAOA,YAAA,IAAG,OAAO,CAAC,UAAU,CAAC,MAAnB,KAA6B,CAAhC;AACE,cAAA,QAAA,GAAW,OAAO,CAAC,UAAW,CAAA,CAAA,CAA9B,CAAA;AAAA,cACA,OAAA,GAAU,OAAQ,CAAA,QAAA,CADlB,CAAA;AAAA,cAEA,OAAA,GAAU,OAAQ,CAAA,QAAA,CAFlB,CADF;aAPA;AAAA,0BAYA,OAAO,CAAC,EAAR,CAAW,OAAX,EAAoB,OAApB,EAZA,CADF;WAAA,MAAA;kCAAA;WAFF;AAAA;wBAjBM;MAAA,CAHR;KADF,CAhIA,CAAA;AAwKA,UACK,CAAA,SAAA,KAAA,GAAA;aAAA,SAAC,QAAD,EAAW,UAAX,GAAA;AAGD,QAAA,MAAM,CAAC,cAAP,CAAsB,QAAtB,EAAgC,QAAhC,EACE;AAAA,UAAA,YAAA,EAAe,KAAf;AAAA,UACA,UAAA,EAAe,IADf;AAAA,UAGA,GAAA,EAAe,SAAC,GAAD,GAAA;mBAAS,QAAQ,CAAC,GAAT,CAAa,QAAb,EAAuB,GAAvB,EAAT;UAAA,CAHf;AAAA,UAKA,GAAA,EAAe,SAAA,GAAA;mBAAG,QAAQ,CAAC,GAAT,CAAa,QAAb,EAAH;UAAA,CALf;SADF,CAAA,CAAA;AAUA,QAAA,IAAG,UAAU,CAAC,SAAD,CAAV,KAAsB,MAAzB;iBACE,QAAS,CAAA,QAAA,CAAT,kDAAqB,UAAU,CAAC,SAAD,aAAV,IAAyB,UAAU,CAAC,SAAD,EAD1D;SAbC;MAAA,EAAA;IAAA,CAAA,CAAA,CAAA,IAAA,CADL;AAAA,SAAA,4BAAA;8CAAA;AACE,UAAI,UAAU,WAAd,CADF;AAAA,KAxKA;AA2LA,IAAA,IAAG,IAAH;aACE,MAAM,CAAC,IAAP,CAAY,QAAZ,EADF;KA7LgB;EAAA,CAhblB,CAAA;;AAinBA,EAAA,IAAG,MAAH;AACE,IAAA,MAAM,CAAC,OAAP,GAAiB,QAAjB,CADF;GAAA,MAAA;AAGE,IAAA,IAAI,CAAC,QAAL,GAAgB,QAAhB,CAHF;GAjnBA;AAAA","file":"Scheming.js","sourceRoot":"/source/","sourcesContent":["# # Annotated Source\n\n# Support node.js or browser environments\nroot = @\n\nisNode = typeof exports != 'undefined' && typeof module != 'undefined' && module.exports\n\n# Depends on lodash\nif isNode\n  _ = require 'lodash'\nelse\n  _ = window._\n\n# Uuid generator for anonymous Schema ids\nuuid = ->\n  now = Date.now()\n  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace /[xy]/g, (c) ->\n    r = (now + Math.random() * 16) % 16 | 0\n    now = Math.floor now / 16\n    ((if c is \"x\" then r else (r & 0x7 | 0x8))).toString 16\n\n# ## Scheming\n\n# ### DEFAULT_OPTIONS\n# Default options for `Schema.create`\nDEFAULT_OPTIONS =\n  seal   : false\n  strict : false\n\n# ### TYPES\n###\n  Scheming exports the default types that it uses for parsing schemas. You can extend with custom types, or\n  override the identifier / parser functions of the default types. A custom type should provide:\n   - ctor (optional) - Used in schema definitions to declare a type. `Scheming.create name : String`\n   - string - Used in schema definitions to declare a type. `Scheming.create name : 'string'`\n   - identifier - Function, returns true or false. Determines whether a value needs to be parsed.\n   - parser - Function, parses a value into the type.\n###\nTYPES =\n  String  :\n    ctor       : String\n    string     : 'string'\n    identifier : _.isString\n    parser     : (val) ->\n      '' + val\n    equals     : (a, b) -> a==b\n  Number  :\n    ctor       : Number\n    string     : 'number'\n    identifier : _.isNumber\n    parser     : parseFloat\n    comparator : (a, b) -> a==b\n    equals     : (a, b) -> a==b\n  Integer :\n    string     : 'integer'\n    identifier : (val) ->\n      _.isNumber(val) && val % 1 == 0\n    parser     : parseInt\n    equals     : (a, b) -> a==b\n  Date    :\n    ctor       : Date\n    string     : 'date'\n    identifier : _.isDate\n    parser     : (val) ->\n      new Date val\n    equals     : (a, b) -> a.valueOf() == b.valueOf()\n  Boolean :\n    ctor       : Boolean\n    string     : 'boolean'\n    identifier : _.isBoolean\n    parser     : (val) ->\n      !!val\n    equals     : (a, b) -> a==b\n  Mixed   :\n    ctor       : (val) ->\n      val\n    string     : '*'\n    identifier : ->\n      true\n    parser     : _.identity\n    equals     : (a, b) -> a==b\n\n# ### NESTED_TYPES\n###\n  Special type definitions for nested types. Used to identify and parse nested Arrays and Schemas.\n  Should not be extended or overridden.\n###\nNESTED_TYPES =\n  Array  :\n    ctor        : Array\n    string      : 'array'\n    identifier  : _.isArray\n    parser      : _.toArray\n    childType   : null\n    childParser : null\n    equals     : (a, b) -> _.isEqual a, b\n  Schema :\n    ctor       : Object\n    string     : 'schema'\n    identifier : null\n    parser     : null\n    childType  : null\n    equals     : (a, b) -> a == b\n\n\n# Used internally to resolve a type declaration to its primitive type.\n# Matches a primitive type if it is...\n# - a reference to the object straight from the `Schema.TYPES` object\n# - a reference to the `ctor`\n# - a match with the type `string` (case insensitive)\ngetPrimitiveTypeOf = (type) ->\n  for k, TYPE of TYPES\n    if type == TYPE or\n        (TYPE.ctor && type == TYPE.ctor) or\n        type?.toLowerCase?() == TYPE.string\n\n      return TYPE\n\n  return null\n\n# Expose TYPES and DEFAULT_OPTIONS for extension and overriding\nScheming = {uuid, TYPES, NESTED_TYPES, DEFAULT_OPTIONS}\n\n# ### resolveType\n# Resolves a type declaration to a primitive or nested type. Used internally when normalizing a schema.\nScheming.resolveType = (typeDef) ->\n  # - Attempt to resolve the type declaration to a primitive type\n  type = getPrimitiveTypeOf typeDef\n\n  if !type?\n    # - If the type definition is an array `[]`\n    if _.isArray typeDef\n      #   - Set the type to a clone of the array NESTED_TYPE\n      type = _.cloneDeep NESTED_TYPES.Array\n\n      #   - Recurse to resolve childType of array members\n      if typeDef.length\n        childType = Scheming.resolveType(typeDef[0])\n\n      #   - Throw an error if type is not explicitly declared\n      if !childType then throw new Error \"Error resolving type of array value #{typeDef}\"\n\n      type.childType = childType\n      #   - Write parser for child members of the array\n      type.childParser = (val) ->\n        for index, member of val\n          if !childType.identifier(member)\n            val[index] = childType.parser(member)\n\n        return val\n\n    # Function that builds identifier and parser for nested schema types. Needs to be factored out\n    # because nested schemas may be resolved lazily at a later time\n    resolveSchemaType = (type, childType) ->\n      type.childType = childType\n      type.identifier = (val) ->\n        return val instanceof childType\n      type.parser = (val) ->\n        return new childType(val)\n\n    ###\n    - If the type definition is an object `{}`\n      - Create a new Schema from the object\n      - Treat the field as a nested Schema\n      - Set identifier and parser functions immediately\n    ###\n    if _.isPlainObject typeDef\n      type = _.cloneDeep NESTED_TYPES.Schema\n      childType = Scheming.create typeDef\n      resolveSchemaType type, childType\n\n    ###\n    - If the type definition is a reference to a Schema constructor\n      - Treat the field as a nested Schema\n      - Set identifier and parser functions immediately\n    ###\n    if _.isFunction(typeDef) && typeDef.__schemaId\n      type = _.cloneDeep NESTED_TYPES.Schema\n      childType = typeDef\n      resolveSchemaType type, childType\n\n    ###\n    - If the type definition is a string that begins with Schema:, such as `'Schema:Car'`\n      - It is assumed that the field is a reference to a nested Schema that will be registered with the name Car,\n    but may not be registered yet\n      - The Schema is not resolved immediately\n      - The parser and identifier functions are written as wrappers, so that the first time they are invoked the Schema\n    will be looked up at that time via `Scheming.get`, and real identifier and parser are set at that time.\n      - If the registered Schema cannot be resolved, throw an error.\n    ###\n    if _.isString(typeDef) && typeDef[...7] == 'Schema:'\n      type = _.cloneDeep NESTED_TYPES.Schema\n      childType = typeDef[7..]\n      for fn in ['identifier', 'parser']\n        do (fn) ->\n          type[fn] = (val) ->\n            childType = Scheming.get childType\n            if !childType\n              throw new Error \"Error resolving #{typeDef} on lazy initialization\"\n            resolveSchemaType type, childType\n\n            return type[fn] val\n\n  return type || null\n\n# ### normalizePropertyConfig\n###\n  Normalizes a field declaration on a schema to capture type, default value, setter, getter, and validation.\n  Used internally when a schema is created to build a normalized schema definition.\n###\nScheming.normalizePropertyConfig = (propConfig, propName = 'field') ->\n  # initialize normalized property definition that we will return\n  definition =\n    type       : null\n    default    : null\n    getter     : null\n    setter     : null\n    validate   : null\n    required   : false\n\n  # if property configuration is not an object with a type key, assume that\n  # the configuration value is just the property type\n  if !(_.isPlainObject(propConfig) && propConfig.type?)\n    propConfig = {type : propConfig}\n\n  {type, getter, setter, validate, required} = propConfig\n  # This function throws errors on any bad configuration, attempting to fail fast.\n\n  # - Throw an error if type is not defined. Type must always be explicitly declared. Untyped fields\n  # must explicitly declared as Schema.TYPES.Mixed\n  if !type?\n    throw new Error \"Error resolving #{propName}. Schema type must be defined.\"\n  # - Throw an error if getter is not a function\n  if getter? && !_.isFunction getter\n    throw new Error \"Error resolving #{propName}. Schema getter must be a function.\"\n  # - Throw an error if setter is not a function\n  if setter? && !_.isFunction setter\n    throw new Error \"Error resolving #{propName}. Schema setter must be a function.\"\n\n  validate ?= []\n  # - If validate is a single function, transform to an array with one member\n  if !_.isArray(validate)\n    validate = [validate]\n  # - Check that all validate are a function, throw an error if it is not.\n  for fn in validate\n    if !_.isFunction fn\n      throw new Error \"Error resolving #{propName}. Schema validate must be a function or array of functions.\"\n\n  # - Resolve the declared type\n  definition.type = Scheming.resolveType type\n\n  # - If type could not be resolved, throw an error\n  if !definition.type?\n    throw new Error \"Error resolving #{propName}. Unrecognized type #{type}\"\n\n  # `default` is a reserved word, so we can't do the nice clean denatured assignment\n  definition.default = propConfig.default\n  definition.getter = getter\n  definition.setter = setter\n  definition.validate = validate\n  definition.required = required\n\n  # allow any custom properties to be exposed on the definition object\n  definition = _.extend {}, propConfig, definition\n\n  # Return a valid property configuration\n  return definition\n\n# Internal registry for schemas created by `Scheming.create`. Schemas are registered by their name, which is either\n# provided at time of creation, or generated as a uuid.\nregistry = {}\n\n# Used internally as part of `Scheming.create`, do not need to expose registration outside of Schema creation.\naddToRegistry = (key, value) ->\n  # Throw an error on naming collisions\n  if registry[key]\n    throw new Error \"Naming conflict encountered. Schema #{key} already exists\"\n  registry[key] = value\n\n# ### get\n# Retrieves a schema by registered name\nScheming.get = (name) ->\n  return registry[name]\n\n# ### reset\n# Resets the state of the Schema registry. Mainly exposed for testing, but could have use in production.\nScheming.reset = ->\n  registry = {}\n\n# ### create\n# Creates a new Schema constructor\nScheming.create = (args...) ->\n  # If the first argument is a string, then the Schema is being named & registered. Otherwise, it is being\n  # created anonymously, and we need to give it a uuid for registration.\n  if !_.isString(args[0])\n    args.unshift uuid()\n\n  # Get name, config, and options from the create arguments\n  [name, schemaConfig, opts] = args\n\n  # Set options, defaulting to the Scheming.DEFAULT_OPTIONS\n  opts = _.defaults (opts || {}), DEFAULT_OPTIONS\n\n  # Build a new Schema\n  Schema = schemaFactory(name, opts)\n\n  # Define properties on the Schema based on the schema configuration\n  Schema.defineProperties schemaConfig\n\n  # Register the new Schema by the name provided or generated\n  addToRegistry name, Schema\n\n  return Schema\n\n# ## Schema\n# Factory method that builds Schema constructors\nschemaFactory = (name, opts) ->\n  # Normalized Schema is captured in closure\n  normalizedSchema = {}\n\n  class Schema\n    # __schemaId property references the schema name and identifies Schema constructors from any other function\n    @__schemaId       : name\n\n    # ### defineProperty\n    # Defines a property on the normalized schema, which is used at time of instance construction\n    @defineProperty   : (propName, propConfig) ->\n      normalizedSchema[propName] = Scheming.normalizePropertyConfig(propConfig, propName)\n\n    # ### defineProperties\n    # Convenience method for defining properties in bulk\n    @defineProperties : (config) ->\n      for k, v of config\n        @defineProperty k, v\n\n    # ### getProperties\n    # returns a clone of the normalized Schema\n    @getProperties : ->\n      return _.cloneDeep normalizedSchema\n\n    # ### getProperty\n    # returns a clone of the normalized Schema property\n    @getProperty : (propName) ->\n      return _.cloneDeep normalizedSchema[propName]\n\n    # ### eachProperty\n    # Iterates over each property name and configuration of the schema, invoking the provided callback\n    @eachProperty : (cb) ->\n      for propName, propConfig of normalizedSchema\n        cb propName, _.cloneDeep propConfig\n\n    # ### validate\n    # Run validation on an instance of the schema\n    @validate : (instance) ->\n      # Create errors hash that will be returned on any validation failure.\n      errors = {}\n\n      # Flag validating state to prevent infinite loop in the case of circular references\n      if instance._validating then return null\n      instance._validating = true\n\n      # Factored code to push error messages onto the errors hash\n      pushError = (key, err) ->\n        if _.isArray err\n          return pushError(key, e) for e in err\n        if !_.isString err\n          err = 'Validation error occurred.'\n        errors[key] ?= []\n        errors[key].push err\n\n      # Apply validation rules\n      for key, value of normalizedSchema\n        {validate, required} = value\n\n        # - Retrieve value. This will be affected by getters.\n        val = instance[key]\n\n        # - If the field is required and not defined, push the error and be done\n        if required && !val?\n          pushError key, \"Field is required.\"\n        # - Only run validation on fields that are defined\n        if val?\n          {type} = normalizedSchema[key]\n\n          # - Run each validator on the field value\n          for validator in validate\n            err = true\n            # - Accept error strings that are returned, or errors that are thrown during processing\n            try\n              err = validator(val)\n            catch e\n              if e then err = e.message\n            # - If any validation errors are detected, push them\n            if err != true then pushError key, err\n\n          # - Additionally, if the property is a nested schema, run its validation\n          if type.string == 'schema'\n            childErrors = type.childType.validate(val)\n            for k, v of childErrors\n              #   - The key on the errors hash should be the path to the field that had a validation error\n              pushError \"#{key}.#{k}\", v\n          # - If the property is an array of schemas, run validation on each member of the array\n          if type.string == 'array' && type.childType.string == 'schema'\n            for member, i in val\n              childErrors = type.childType.childType.validate(member)\n              for k, v of childErrors\n                #   - Again, the key on the errors hash should be the path to the field that had a validation error\n                pushError \"#{key}[#{i}].#{k}\", v\n\n        # Unset flag, indicating validation is complete\n      instance._validating = false\n\n      # Return null if no validation errros ocurred\n      if _.size(errors) == 0\n        return null\n      else\n        return errors\n\n    # ### watch\n    # Watches an instance for changes to one or more properties\n    @watch : (instance, properties, cb) ->\n      instance._addWatcher properties, cb\n\n    # ### constructor\n    # Constructor that builds instances of the Schema\n    constructor       : (model) ->\n\n      # turn `this` into a Schema instance\n      instanceFactory(@, normalizedSchema, opts)\n\n      # Finally, initialize the instance with the model passed to the constructor\n      @set model\n\n# ## Instance\n# Factory method that builds accepts an object and turns it into a Schema instance\ninstanceFactory = (instance, normalizedSchema, opts)->\n  # data hash wrapped in closure, keeps actual data members private\n  data = {}\n\n  {strict, seal} = opts\n\n  Object.defineProperty instance, 'set',\n    configurable : false\n    enumerable : false\n    writable : false\n    value : (propName, val) ->\n      prevVals = {}\n      kvp = {}\n\n      if arguments.length == 2\n        kvp[propName] = val\n      else\n        kvp = propName\n\n      for propName, val of kvp\n        prevVal = data[propName]\n\n        # if the property is not a part of the schema, simply set it on the instance.\n        # if the seal option is enabled this will fail silently, otherwise it will allow for arbitrary properties\n        if !normalizedSchema[propName]\n          return instance[propName] = val\n\n        # retrieve the type, getter, and setter from the normalized field config\n        {type, setter} = normalizedSchema[propName]\n\n        # - If a property is set to undefined, do not type cast or run through setter.\n        # You should always be able to clear a property.\n        if val is undefined\n          data[propName] = val\n        else\n          # - If value is not undefined, run through type identifier to determine if it is the correct type\n          if !type.identifier(val)\n            #   - If not and strict mode is enabled, throw an error\n            if strict then throw new Error \"Error assigning #{val} to #{propName}. Value is not of type #{type.string}\"\n            #   - Otherwise, use parser to cast to the correct type\n            val = type.parser val\n          # - If the property type is of array, perform parsing on child members.\n          if type.string == NESTED_TYPES.Array.string\n            val = type.childParser val\n          # - If a setter is defined, run the value through setter\n          if setter\n            val = setter val\n          # - Assign to the data hash\n          data[propName] = val\n          # - Finally, check if the value has changed and needs to fire a watch\n          if !type.equals prevVal, val\n            prevVals[propName] = prevVal\n\n      @_fireWatchers prevVals\n\n  Object.defineProperty instance, 'get',\n    configurable : false\n    enumerable : false\n    writable : false\n    value : (propName) ->\n      # retrieve the type, getter, and setter from the normalized field config\n      {type, getter} = normalizedSchema[propName]\n\n      # - Retrieve data value from the hash\n      val = data[propName]\n      # - If value is not defined, immediately return it.\n      if val is undefined\n        return val\n      # - Return a clone of the original value to protect data from mutation\n      unless type.string == 'schema'\n        val = _.clone val\n      # - If getter is defined, run value through getter\n      if getter\n        val = getter val\n      # - Finally, return the value\n      return val\n\n  # Define a _validating flag, which is used to prevent infinite loops on validation of circular references\n  Object.defineProperty instance, '_validating',\n    configurable : false\n    enumerable : false\n    writable : true\n    value : false\n\n  # Set up the _watchers hash\n  Object.defineProperty instance, '_watchers',\n    configurable : false\n    enumerable : false\n    writable : true\n    value : []\n\n  Object.defineProperty instance, '_addWatcher',\n    configurable : false\n    enumerable : false\n    writable : true\n    value : (properties, cb) ->\n      if _.isFunction properties\n        cb = properties\n        properties = _.keys normalizedSchema\n\n      if !_.isFunction cb\n        throw new Error 'A watch must be provided with a callback function.'\n\n      if properties && !_.isArray properties\n        properties = [properties]\n\n      newVals = {}\n      for propName in properties\n        if !_.has normalizedSchema, propName\n          throw new Error \"Cannot set watch on #{propName}, property is not defined in schema.\"\n        newVals[propName] = instance[propName]\n      if properties.length == 1\n        newVals = newVals[propName]\n\n      cb newVals, newVals\n\n      watcher = {properties, cb}\n      instance._watchers.push watcher\n\n      # returns an unwatch function\n      return ->\n        instance._removeWatcher watcher\n\n  Object.defineProperty instance, '_removeWatcher',\n    configurable : false\n    enumerable : false\n    writable : true\n    value : (watcher) ->\n      _.remove instance._watchers, watcher\n\n  Object.defineProperty instance, '_fireWatchers',\n    configurable : false\n    enumerable : false\n    writable : true\n    value : (prevVals) ->\n      triggeringProperties = _.keys prevVals\n\n      cached = {}\n      getCurrentVal = (propName) ->\n        if cached[propName]\n          return cached[propName]\n        else\n          val = instance[propName]\n          cached[propName] = val\n          return val\n      getPrevVal = (propName) ->\n        if _.has prevVals, propName\n          return prevVals[propName]\n        else\n          return getCurrentVal(propName)\n\n      for watcher in instance._watchers\n        shouldFire = _.intersection(triggeringProperties, watcher.properties).length > 0\n        if shouldFire\n          newVals = {}\n          oldVals = {}\n\n          for propName in watcher.properties\n            newVals[propName] = getCurrentVal(propName)\n            oldVals[propName] = getPrevVal(propName)\n\n          if watcher.properties.length == 1\n            propName = watcher.properties[0]\n            newVals = newVals[propName]\n            oldVals = oldVals[propName]\n\n          watcher.cb newVals, oldVals\n\n  # ### constructor\n  # for each property of the normalized schema\n  for propName, propConfig of normalizedSchema\n    do (propName, propConfig) =>\n      # define an enumerable property on the instance that is not configurable\n      # user get and set to manage getters, setters, and type parsing\n      Object.defineProperty instance, propName,\n        configurable : false\n        enumerable   : true\n        # **set**\n        set          : (val) -> instance.set propName, val\n        # **get**\n        get          : -> instance.get propName\n\n      # Once the property is configured, assign a default value. This ensures that default values are still\n      # affected by type parsing and setters\n      if propConfig.default != undefined\n        instance[propName] = propConfig.default?() || propConfig.default\n\n  # If seal option is enabled, seal the instance, preventing addition of other properties besides those explicitly\n  # defined by the Schema\n  if seal\n    Object.seal instance\n\n# All done. Export onto the correct root.\nif isNode\n  module.exports = Scheming\nelse\n  root.Scheming = Scheming"]}