<!DOCTYPE html><html lang="en"><head><title>src/Scheming</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/Scheming"><meta name="groc-project-path" content="src/Scheming.coffee"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/Scheming.coffee</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper">root = @

isNode = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> != <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> != <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span>

<span class="hljs-keyword">if</span> isNode
  _ = <span class="hljs-built_in">require</span> <span class="hljs-string">'lodash'</span>

<span class="hljs-function"><span class="hljs-title">uuid</span> = -&gt;</span>
  now = Date.now()
  <span class="hljs-string">'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'</span>.replace <span class="hljs-regexp">/[xy]/g</span>, <span class="hljs-function"><span class="hljs-params">(c)</span> -&gt;</span>
    r = (now + Math.random() * <span class="hljs-number">16</span>) % <span class="hljs-number">16</span> | <span class="hljs-number">0</span>
    now = Math.floor now / <span class="hljs-number">16</span>
    ((<span class="hljs-keyword">if</span> c <span class="hljs-keyword">is</span> <span class="hljs-string">"x"</span> <span class="hljs-keyword">then</span> r <span class="hljs-keyword">else</span> (r &amp; <span class="hljs-number">0x7</span> | <span class="hljs-number">0x8</span>))).toString <span class="hljs-number">16</span>

RESERVED_PROPERTIES =
  validate : <span class="hljs-string">'validate'</span>

TYPES =
  String  :
    ctor       : String
    string     : <span class="hljs-string">'string'</span>
    identifier : _.isString
    parser     : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      <span class="hljs-string">''</span> + val
  Number  :
    ctor       : Number
    string     : <span class="hljs-string">'number'</span>
    identifier : _.isNumber
    parser     : parseFloat
  Integer :
    string     : <span class="hljs-string">'integer'</span>
    identifier : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      _.isNumber(val) &amp;&amp; val % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>
    parser     : parseInt
  Float   :
    string     : <span class="hljs-string">'float'</span>
    identifier : _.isNumber
    parser     : parseFloat
  Date    :
    ctor       : Date
    string     : <span class="hljs-string">'date'</span>
    identifier : _.isDate
    parser     : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      <span class="hljs-keyword">new</span> Date val
  Boolean :
    ctor       : Boolean
    string     : <span class="hljs-string">'boolean'</span>
    identifier : _.isBoolean
    parser     : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      !!val
  Mixed   :
    ctor       : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      val
    string     : <span class="hljs-string">'*'</span>
    identifier :<span class="hljs-function"> -&gt;</span>
      <span class="hljs-literal">true</span>
    parser     : _.identity</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>parsers for nested types are dynamic and must be built at resolution time</p></div></div><div class="code"><div class="wrapper">NESTED_TYPES =
  Array  :
    ctor        : Array
    string      : <span class="hljs-string">'array'</span>
    identifier  : _.isArray
    childType   : <span class="hljs-literal">null</span>
    parser      : _.toArray
    childParser : _.toArray
  Schema :
    ctor       : Object
    string     : <span class="hljs-string">'schema'</span>
    identifier : <span class="hljs-literal">null</span>
    childType  : <span class="hljs-literal">null</span>
    parser     : <span class="hljs-literal">null</span>

<span class="hljs-function"><span class="hljs-title">getPrimitiveTypeOf</span> = <span class="hljs-params">(type)</span> -&gt;</span>
  <span class="hljs-keyword">for</span> k, TYPE <span class="hljs-keyword">of</span> TYPES
    <span class="hljs-keyword">if</span> type == TYPE <span class="hljs-keyword">or</span>
        (TYPE.ctor &amp;&amp; type == TYPE.ctor) <span class="hljs-keyword">or</span>
        type?.toLowerCase?() == TYPE.string

      <span class="hljs-keyword">return</span> TYPE

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>

Scheming = {TYPES, NESTED_TYPES, RESERVED_PROPERTIES}

Scheming.<span class="hljs-function"><span class="hljs-title">resolveType</span> = <span class="hljs-params">(typeDef)</span> -&gt;</span>
  type = getPrimitiveTypeOf typeDef

  <span class="hljs-keyword">if</span> !type?
    <span class="hljs-keyword">if</span> _.isArray typeDef
      type = _.cloneDeep NESTED_TYPES.Array
      childType = TYPES.Mixed

      <span class="hljs-keyword">if</span> typeDef.length
        childType = Scheming.resolveType(typeDef[<span class="hljs-number">0</span>])

      type.childType = childType
      type.<span class="hljs-function"><span class="hljs-title">childParser</span> = <span class="hljs-params">(val)</span> -&gt;</span>
        <span class="hljs-keyword">for</span> index, member <span class="hljs-keyword">of</span> val
          <span class="hljs-keyword">if</span> !childType.identifier(member)
            val[index] = childType.parser(member)

        <span class="hljs-keyword">return</span> val

    <span class="hljs-function"><span class="hljs-title">resolveSchemaType</span> = <span class="hljs-params">(type, childType)</span> -&gt;</span>
      type.childType = childType
      type.<span class="hljs-function"><span class="hljs-title">identifier</span> = <span class="hljs-params">(val)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> val <span class="hljs-keyword">instanceof</span> childType
      type.<span class="hljs-function"><span class="hljs-title">parser</span> = <span class="hljs-params">(val)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> childType(val)

    <span class="hljs-keyword">if</span> _.isPlainObject typeDef
      type = _.cloneDeep NESTED_TYPES.Schema
      childType = Scheming.create typeDef
      resolveSchemaType type, childType

    <span class="hljs-keyword">if</span> _.isFunction(typeDef) &amp;&amp; typeDef.__skemaId
      type = _.cloneDeep NESTED_TYPES.Schema
      childType = typeDef
      resolveSchemaType type, childType

    <span class="hljs-keyword">if</span> _.isString(typeDef) &amp;&amp; typeDef[..<span class="hljs-number">.7</span>] == <span class="hljs-string">'Schema:'</span>
      type = _.cloneDeep NESTED_TYPES.Schema
      childType = typeDef[<span class="hljs-number">7.</span>.]
      <span class="hljs-keyword">for</span> fn <span class="hljs-keyword">in</span> [<span class="hljs-string">'identifier'</span>, <span class="hljs-string">'parser'</span>]
        <span class="hljs-keyword">do</span> <span class="hljs-function"><span class="hljs-params">(fn)</span> -&gt;</span>
          type[fn] = <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
            childType = Scheming.get childType
            <span class="hljs-keyword">if</span> !childType
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{typeDef}</span> on lazy initialization"</span>
            resolveSchemaType type, childType

            <span class="hljs-keyword">return</span> type[fn] val

  <span class="hljs-keyword">return</span> type || <span class="hljs-literal">null</span>

Scheming.<span class="hljs-function"><span class="hljs-title">normalizeProperty</span> = <span class="hljs-params">(config, fieldName)</span> -&gt;</span>
  definition =
    type       : <span class="hljs-literal">null</span>
    <span class="hljs-reserved">default</span>    : <span class="hljs-literal">null</span>
    getter     : <span class="hljs-literal">null</span>
    setter     : <span class="hljs-literal">null</span>
    validators : <span class="hljs-literal">null</span>
    required   : <span class="hljs-literal">false</span>

  <span class="hljs-keyword">if</span> !(_.isPlainObject(config) &amp;&amp; config.type?)
    config = {type : config}

  {type, getter, setter, validate, required} = config

  <span class="hljs-keyword">if</span> !type?
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{fieldName}</span>. Schema type must be defined."</span>
  <span class="hljs-keyword">if</span> getter? &amp;&amp; !_.isFunction getter
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{fieldName}</span>. Schema getter must be a function."</span>
  <span class="hljs-keyword">if</span> setter? &amp;&amp; !_.isFunction setter
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{fieldName}</span>. Schema setter must be a function."</span>

  validate ?= []
  <span class="hljs-keyword">if</span> !_.isArray(validate)
    validate = [validate]
  <span class="hljs-keyword">for</span> fn <span class="hljs-keyword">in</span> validate
    <span class="hljs-keyword">if</span> !_.isFunction fn
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{fieldName}</span>. Schema validate must be a function or array of functions."</span>

  definition.type = Scheming.resolveType type

  <span class="hljs-keyword">if</span> !definition.type?
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{fieldName}</span>. Unrecognized type <span class="hljs-subst">#{type}</span>"</span>

  definition.<span class="hljs-reserved">default</span> = config.<span class="hljs-reserved">default</span>
  definition.getter = getter
  definition.setter = setter
  definition.validators = validate
  definition.required = required

  <span class="hljs-keyword">return</span> definition</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>opts:
  strict - if false, allows attachment of arbitrary properties to object</p></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">## TODO: How to deal with arrays and array mutations for watching</span>
<span class="hljs-comment">## TODO: allowArbitrary : Object.seal - prevent adding / removing of properties</span>
<span class="hljs-comment">## TODO: support strict assignment, so rather than parse, throw an error?</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>  Doc notes -</p>
<ul>
<li>parsers are applied before setters; setters can assume they are receiving correct type</li>
</ul>
<p>name, schemaConfig, opts</p></div></div><div class="code"><div class="wrapper">registry = {}

<span class="hljs-function"><span class="hljs-title">register</span> = <span class="hljs-params">(key, value)</span> -&gt;</span>
  <span class="hljs-keyword">if</span> registry[key]
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Naming conflict encountered. Schema <span class="hljs-subst">#{key}</span> already exists"</span>
  registry[key] = value

Scheming.<span class="hljs-function"><span class="hljs-title">create</span> = <span class="hljs-params">(args...)</span> -&gt;</span>
  <span class="hljs-keyword">if</span> !_.isString(args[<span class="hljs-number">0</span>])
    args.unshift uuid()

  [name, schemaConfig, opts] = args

  normalizedSchema = {}

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Schema</span></span>
    <span class="hljs-property">@__skemaId</span> : name

    <span class="hljs-property">@defineProperties</span> : <span class="hljs-function"><span class="hljs-params">(config)</span> -&gt;</span>
      <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">of</span> config
        <span class="hljs-property">@defineProperty</span> k, v

    <span class="hljs-property">@defineProperty</span> : <span class="hljs-function"><span class="hljs-params">(fieldName, config)</span> -&gt;</span>
      normalizedSchema[fieldName] = Scheming.normalizeProperty(config, fieldName)

    constructor : <span class="hljs-function"><span class="hljs-params">(model)</span> -&gt;</span>
      data = {}

      Object.defineProperty @, <span class="hljs-string">'__skemaId'</span>,
        enumerable   : <span class="hljs-literal">false</span>
        configurable : <span class="hljs-literal">false</span>
        writable     : <span class="hljs-literal">false</span>
        value        : Schema.__skemaId

      <span class="hljs-keyword">for</span> fieldName, typeDefinition <span class="hljs-keyword">of</span> normalizedSchema
        <span class="hljs-keyword">do</span> <span class="hljs-function"><span class="hljs-params">(fieldName, typeDefinition)</span> =&gt;</span>
          {type, getter, setter} = typeDefinition

          Object.defineProperty @, fieldName,
            configurable : <span class="hljs-literal">true</span>
            enumerable   : <span class="hljs-literal">true</span>
            get          :<span class="hljs-function"> -&gt;</span>
              val = data[fieldName]
              <span class="hljs-keyword">if</span> val <span class="hljs-keyword">is</span> <span class="hljs-literal">undefined</span>
                <span class="hljs-keyword">return</span> val
              <span class="hljs-keyword">if</span> type.string == NESTED_TYPES.Array.string
                val = type.childParser val
              <span class="hljs-keyword">if</span> getter
                val = getter val
              <span class="hljs-keyword">return</span> val
            set          : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
              <span class="hljs-keyword">if</span> !type.identifier(val)
                val = type.parser val
              <span class="hljs-keyword">if</span> setter
                val = setter val
              data[fieldName] = val

          <span class="hljs-keyword">if</span> typeDefinition.<span class="hljs-reserved">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">undefined</span>
            @[fieldName] = typeDefinition.<span class="hljs-reserved">default</span>

      <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">of</span> model
        @[key] = value

      <span class="hljs-property">@validate</span> = <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
        errors = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>prevents infinite loops in circular references</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> <span class="hljs-property">@_validating</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        <span class="hljs-property">@_validating</span> = <span class="hljs-literal">true</span>

        <span class="hljs-function"><span class="hljs-title">pushError</span> = <span class="hljs-params">(key, err)</span> -&gt;</span>
          <span class="hljs-keyword">if</span> _.isArray err
            <span class="hljs-keyword">return</span> pushError(key, e) <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> err
          <span class="hljs-keyword">if</span> !_.isString err
            err = <span class="hljs-string">'Validation error occurred.'</span>
          errors[key] ?= []
          errors[key].push err</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>apply validation rules</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">of</span> normalizedSchema

          {validators, required} = value

          val = @[key]

          <span class="hljs-keyword">if</span> required &amp;&amp; !val?
            pushError key, <span class="hljs-string">"Field is required."</span>
          <span class="hljs-keyword">if</span> val?
            {type} = normalizedSchema[key]

            <span class="hljs-keyword">for</span> validator <span class="hljs-keyword">in</span> validators
              err = <span class="hljs-literal">true</span>
              <span class="hljs-keyword">try</span>
                err = validator(val)
              <span class="hljs-keyword">catch</span> e
                <span class="hljs-keyword">if</span> e <span class="hljs-keyword">then</span> err = e.message
              <span class="hljs-keyword">if</span> err != <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span> pushError key, err

            <span class="hljs-keyword">if</span> type.string == <span class="hljs-string">'schema'</span>
              childErrors = val.validate()
              <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">of</span> childErrors
                pushError <span class="hljs-string">"<span class="hljs-subst">#{key}</span>.<span class="hljs-subst">#{k}</span>"</span>, v
            <span class="hljs-keyword">if</span> type.string == <span class="hljs-string">'array'</span> &amp;&amp; type.childType.string == <span class="hljs-string">'schema'</span>
              <span class="hljs-keyword">for</span> member, i <span class="hljs-keyword">in</span> val
                childErrors = member.validate()
                <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">of</span> childErrors
                  pushError <span class="hljs-string">"<span class="hljs-subst">#{key}</span>[<span class="hljs-subst">#{i}</span>].<span class="hljs-subst">#{k}</span>"</span>, v

        <span class="hljs-property">@_validating</span> = <span class="hljs-literal">false</span>

        <span class="hljs-keyword">if</span> _.size(errors) == <span class="hljs-number">0</span>
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        <span class="hljs-keyword">else</span>
          <span class="hljs-keyword">return</span> errors

  Schema.defineProperties schemaConfig

  register name, Schema

  <span class="hljs-keyword">return</span> Schema

Scheming.<span class="hljs-function"><span class="hljs-title">get</span> = <span class="hljs-params">(name)</span> -&gt;</span>
  <span class="hljs-keyword">return</span> registry[name]

Scheming.<span class="hljs-function"><span class="hljs-title">reset</span> = -&gt;</span>
  registry = {}

<span class="hljs-keyword">if</span> isNode
  <span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = Scheming
<span class="hljs-keyword">else</span>
  root.Scheming = Scheming</div></div></div></div></body></html>