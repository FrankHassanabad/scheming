<!DOCTYPE html><html lang="en"><head><title>Scheming</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="Scheming"><meta name="groc-project-path" content="src/Scheming.coffee"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/Scheming.coffee</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="annotated-source">Annotated Source</h1></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support node.js or browser environments</p></div></div><div class="code"><div class="wrapper">root = @

isNode = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> != <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> != <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Depends on lodash</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">if</span> isNode
  _ = <span class="hljs-built_in">require</span> <span class="hljs-string">'lodash'</span>
<span class="hljs-keyword">else</span>
  _ = <span class="hljs-built_in">window</span>._</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Uuid generator for anonymous Schema ids</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-title">uuid</span> = -&gt;</span>
  now = Date.now()
  <span class="hljs-string">'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'</span>.replace <span class="hljs-regexp">/[xy]/g</span>, <span class="hljs-function"><span class="hljs-params">(c)</span> -&gt;</span>
    r = (now + Math.random() * <span class="hljs-number">16</span>) % <span class="hljs-number">16</span> | <span class="hljs-number">0</span>
    now = Math.floor now / <span class="hljs-number">16</span>
    ((<span class="hljs-keyword">if</span> c <span class="hljs-keyword">is</span> <span class="hljs-string">"x"</span> <span class="hljs-keyword">then</span> r <span class="hljs-keyword">else</span> (r &amp; <span class="hljs-number">0x7</span> | <span class="hljs-number">0x8</span>))).toString <span class="hljs-number">16</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="scheming">Scheming</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="default-options">DEFAULT_OPTIONS</h3>
<p>Default options for <code>Schema.create</code></p></div></div><div class="code"><div class="wrapper">DEFAULT_OPTIONS =
  seal   : <span class="hljs-literal">false</span>
  strict : <span class="hljs-literal">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="types">TYPES</h3>
<p>  Scheming exports the default types that it uses for parsing schemas. You can extend with custom types, or
  override the identifier / parser functions of the default types. A custom type should provide:</p>
<ul>
<li>ctor (optional) - Used in schema definitions to declare a type. <code>Scheming.create name : String</code></li>
<li>string - Used in schema definitions to declare a type. <code>Scheming.create name : &#39;string&#39;</code></li>
<li>identifier - Function, returns true or false. Determines whether a value needs to be parsed.</li>
<li>parser - Function, parses a value into the type.</li>
</ul></div></div><div class="code"><div class="wrapper">TYPES =
  String  :
    ctor       : String
    string     : <span class="hljs-string">'string'</span>
    identifier : _.isString
    parser     : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      <span class="hljs-string">''</span> + val
    equals     : <span class="hljs-function"><span class="hljs-params">(a, b)</span> -&gt;</span> a==b
  Number  :
    ctor       : Number
    string     : <span class="hljs-string">'number'</span>
    identifier : _.isNumber
    parser     : parseFloat
    comparator : <span class="hljs-function"><span class="hljs-params">(a, b)</span> -&gt;</span> a==b
    equals     : <span class="hljs-function"><span class="hljs-params">(a, b)</span> -&gt;</span> a==b
  Integer :
    string     : <span class="hljs-string">'integer'</span>
    identifier : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      _.isNumber(val) &amp;&amp; val % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>
    parser     : parseInt
    equals     : <span class="hljs-function"><span class="hljs-params">(a, b)</span> -&gt;</span> a==b
  Date    :
    ctor       : Date
    string     : <span class="hljs-string">'date'</span>
    identifier : _.isDate
    parser     : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      <span class="hljs-keyword">new</span> Date val
    equals     : <span class="hljs-function"><span class="hljs-params">(a, b)</span> -&gt;</span> a.valueOf() == b.valueOf()
  Boolean :
    ctor       : Boolean
    string     : <span class="hljs-string">'boolean'</span>
    identifier : _.isBoolean
    parser     : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      !!val
    equals     : <span class="hljs-function"><span class="hljs-params">(a, b)</span> -&gt;</span> a==b
  Mixed   :
    ctor       : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      val
    string     : <span class="hljs-string">'*'</span>
    identifier :<span class="hljs-function"> -&gt;</span>
      <span class="hljs-literal">true</span>
    parser     : _.identity
    equals     : <span class="hljs-function"><span class="hljs-params">(a, b)</span> -&gt;</span> a==b</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="nested-types">NESTED_TYPES</h3>
<p>  Special type definitions for nested types. Used to identify and parse nested Arrays and Schemas.
  Should not be extended or overridden.</p></div></div><div class="code"><div class="wrapper">NESTED_TYPES =
  Array  :
    ctor        : Array
    string      : <span class="hljs-string">'array'</span>
    identifier  : _.isArray
    parser      : _.toArray
    childType   : <span class="hljs-literal">null</span>
    childParser : <span class="hljs-literal">null</span>
    equals     : <span class="hljs-function"><span class="hljs-params">(a, b)</span> -&gt;</span> _.isEqual a, b
  Schema :
    ctor       : Object
    string     : <span class="hljs-string">'schema'</span>
    identifier : <span class="hljs-literal">null</span>
    parser     : <span class="hljs-literal">null</span>
    childType  : <span class="hljs-literal">null</span>
    equals     : <span class="hljs-function"><span class="hljs-params">(a, b)</span> -&gt;</span> a == b</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used internally to resolve a type declaration to its primitive type.
Matches a primitive type if it is...</p>
<ul>
<li>a reference to the object straight from the <code>Schema.TYPES</code> object</li>
<li>a reference to the <code>ctor</code></li>
<li>a match with the type <code>string</code> (case insensitive)</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-title">getPrimitiveTypeOf</span> = <span class="hljs-params">(type)</span> -&gt;</span>
  <span class="hljs-keyword">for</span> k, TYPE <span class="hljs-keyword">of</span> TYPES
    <span class="hljs-keyword">if</span> type == TYPE <span class="hljs-keyword">or</span>
        (TYPE.ctor &amp;&amp; type == TYPE.ctor) <span class="hljs-keyword">or</span>
        type?.toLowerCase?() == TYPE.string

      <span class="hljs-keyword">return</span> TYPE

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Expose TYPES and DEFAULT_OPTIONS for extension and overriding</p></div></div><div class="code"><div class="wrapper">Scheming = {uuid, TYPES, NESTED_TYPES, DEFAULT_OPTIONS}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="resolvetype">resolveType</h3>
<p>Resolves a type declaration to a primitive or nested type. Used internally when normalizing a schema.</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">resolveType</span> = <span class="hljs-params">(typeDef)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Attempt to resolve the type declaration to a primitive type</li>
</ul></div></div><div class="code"><div class="wrapper">  type = getPrimitiveTypeOf typeDef

  <span class="hljs-keyword">if</span> !type?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the type definition is an array <code>[]</code></li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> _.isArray typeDef</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Set the type to a clone of the array NESTED_TYPE</li>
</ul></div></div><div class="code"><div class="wrapper">      type = _.cloneDeep NESTED_TYPES.Array</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Recurse to resolve childType of array members</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> typeDef.length
        childType = Scheming.resolveType(typeDef[<span class="hljs-number">0</span>])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Throw an error if type is not explicitly declared</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> !childType <span class="hljs-keyword">then</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving type of array value <span class="hljs-subst">#{typeDef}</span>"</span>

      type.childType = childType</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Write parser for child members of the array</li>
</ul></div></div><div class="code"><div class="wrapper">      type.<span class="hljs-function"><span class="hljs-title">childParser</span> = <span class="hljs-params">(val)</span> -&gt;</span>
        <span class="hljs-keyword">for</span> index, member <span class="hljs-keyword">of</span> val
          <span class="hljs-keyword">if</span> !childType.identifier(member)
            val[index] = childType.parser(member)

        <span class="hljs-keyword">return</span> val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function that builds identifier and parser for nested schema types. Needs to be factored out
because nested schemas may be resolved lazily at a later time</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-title">resolveSchemaType</span> = <span class="hljs-params">(type, childType)</span> -&gt;</span>
      type.childType = childType
      type.<span class="hljs-function"><span class="hljs-title">identifier</span> = <span class="hljs-params">(val)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> val <span class="hljs-keyword">instanceof</span> childType
      type.<span class="hljs-function"><span class="hljs-title">parser</span> = <span class="hljs-params">(val)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> childType(val)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the type definition is an object <code>{}</code><ul>
<li>Create a new Schema from the object</li>
<li>Treat the field as a nested Schema</li>
<li>Set identifier and parser functions immediately</li>
</ul>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> _.isPlainObject typeDef
      type = _.cloneDeep NESTED_TYPES.Schema
      childType = Scheming.create typeDef
      resolveSchemaType type, childType</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the type definition is a reference to a Schema constructor<ul>
<li>Treat the field as a nested Schema</li>
<li>Set identifier and parser functions immediately</li>
</ul>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> _.isFunction(typeDef) &amp;&amp; typeDef.__schemaId
      type = _.cloneDeep NESTED_TYPES.Schema
      childType = typeDef
      resolveSchemaType type, childType</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the type definition is a string that begins with Schema:, such as <code>&#39;Schema:Car&#39;</code><ul>
<li>It is assumed that the field is a reference to a nested Schema that will be registered with the name Car,
but may not be registered yet</li>
<li>The Schema is not resolved immediately</li>
<li>The parser and identifier functions are written as wrappers, so that the first time they are invoked the Schema
will be looked up at that time via <code>Scheming.get</code>, and real identifier and parser are set at that time.</li>
<li>If the registered Schema cannot be resolved, throw an error.</li>
</ul>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> _.isString(typeDef) &amp;&amp; typeDef[..<span class="hljs-number">.7</span>] == <span class="hljs-string">'Schema:'</span>
      type = _.cloneDeep NESTED_TYPES.Schema
      childType = typeDef[<span class="hljs-number">7.</span>.]
      <span class="hljs-keyword">for</span> fn <span class="hljs-keyword">in</span> [<span class="hljs-string">'identifier'</span>, <span class="hljs-string">'parser'</span>]
        <span class="hljs-keyword">do</span> <span class="hljs-function"><span class="hljs-params">(fn)</span> -&gt;</span>
          type[fn] = <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
            childType = Scheming.get childType
            <span class="hljs-keyword">if</span> !childType
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{typeDef}</span> on lazy initialization"</span>
            resolveSchemaType type, childType

            <span class="hljs-keyword">return</span> type[fn] val

  <span class="hljs-keyword">return</span> type || <span class="hljs-literal">null</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="normalizepropertyconfig">normalizePropertyConfig</h3>
<p>  Normalizes a field declaration on a schema to capture type, default value, setter, getter, and validation.
  Used internally when a schema is created to build a normalized schema definition.</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">normalizePropertyConfig</span> = <span class="hljs-params">(propConfig, propName = <span class="hljs-string">'field'</span>)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>initialize normalized property definition that we will return</p></div></div><div class="code"><div class="wrapper">  definition =
    type       : <span class="hljs-literal">null</span>
    <span class="hljs-reserved">default</span>    : <span class="hljs-literal">null</span>
    getter     : <span class="hljs-literal">null</span>
    setter     : <span class="hljs-literal">null</span>
    validate   : <span class="hljs-literal">null</span>
    required   : <span class="hljs-literal">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if property configuration is not an object with a type key, assume that
the configuration value is just the property type</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> !(_.isPlainObject(propConfig) &amp;&amp; propConfig.type?)
    propConfig = {type : propConfig}

  {type, getter, setter, validate, required} = propConfig</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function throws errors on any bad configuration, attempting to fail fast.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Throw an error if type is not defined. Type must always be explicitly declared. Untyped fields
must explicitly declared as Schema.TYPES.Mixed</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> !type?
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{propName}</span>. Schema type must be defined."</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Throw an error if getter is not a function</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> getter? &amp;&amp; !_.isFunction getter
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{propName}</span>. Schema getter must be a function."</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Throw an error if setter is not a function</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> setter? &amp;&amp; !_.isFunction setter
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{propName}</span>. Schema setter must be a function."</span>

  validate ?= []</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If validate is a single function, transform to an array with one member</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> !_.isArray(validate)
    validate = [validate]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Check that all validate are a function, throw an error if it is not.</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">for</span> fn <span class="hljs-keyword">in</span> validate
    <span class="hljs-keyword">if</span> !_.isFunction fn
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{propName}</span>. Schema validate must be a function or array of functions."</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Resolve the declared type</li>
</ul></div></div><div class="code"><div class="wrapper">  definition.type = Scheming.resolveType type</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If type could not be resolved, throw an error</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> !definition.type?
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{propName}</span>. Unrecognized type <span class="hljs-subst">#{type}</span>"</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>default</code> is a reserved word, so we can&#39;t do the nice clean denatured assignment</p></div></div><div class="code"><div class="wrapper">  definition.<span class="hljs-reserved">default</span> = propConfig.<span class="hljs-reserved">default</span>
  definition.getter = getter
  definition.setter = setter
  definition.validate = validate
  definition.required = required</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>allow any custom properties to be exposed on the definition object</p></div></div><div class="code"><div class="wrapper">  definition = _.extend {}, propConfig, definition</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return a valid property configuration</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">return</span> definition</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Internal registry for schemas created by <code>Scheming.create</code>. Schemas are registered by their name, which is either
provided at time of creation, or generated as a uuid.</p></div></div><div class="code"><div class="wrapper">registry = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used internally as part of <code>Scheming.create</code>, do not need to expose registration outside of Schema creation.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-title">addToRegistry</span> = <span class="hljs-params">(key, value)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Throw an error on naming collisions</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> registry[key]
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Naming conflict encountered. Schema <span class="hljs-subst">#{key}</span> already exists"</span>
  registry[key] = value</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="get">get</h3>
<p>Retrieves a schema by registered name</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">get</span> = <span class="hljs-params">(name)</span> -&gt;</span>
  <span class="hljs-keyword">return</span> registry[name]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="reset">reset</h3>
<p>Resets the state of the Schema registry. Mainly exposed for testing, but could have use in production.</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">reset</span> = -&gt;</span>
  registry = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="create">create</h3>
<p>Creates a new Schema constructor</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">create</span> = <span class="hljs-params">(args...)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the first argument is a string, then the Schema is being named &amp; registered. Otherwise, it is being
created anonymously, and we need to give it a uuid for registration.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> !_.isString(args[<span class="hljs-number">0</span>])
    args.unshift uuid()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get name, config, and options from the create arguments</p></div></div><div class="code"><div class="wrapper">  [name, schemaConfig, opts] = args</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set options, defaulting to the Scheming.DEFAULT_OPTIONS</p></div></div><div class="code"><div class="wrapper">  opts = _.defaults (opts || {}), DEFAULT_OPTIONS</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build a new Schema</p></div></div><div class="code"><div class="wrapper">  Schema = schemaFactory(name, opts)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define properties on the Schema based on the schema configuration</p></div></div><div class="code"><div class="wrapper">  Schema.defineProperties schemaConfig</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Register the new Schema by the name provided or generated</p></div></div><div class="code"><div class="wrapper">  addToRegistry name, Schema

  <span class="hljs-keyword">return</span> Schema</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="schema">Schema</h2>
<p>Factory method that builds Schema constructors</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-title">schemaFactory</span> = <span class="hljs-params">(name, opts)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Normalized Schema is captured in closure</p></div></div><div class="code"><div class="wrapper">  normalizedSchema = {}

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Schema</span></span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>__schemaId property references the schema name and identifies Schema constructors from any other function</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@__schemaId</span>       : name</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="defineproperty">defineProperty</h3>
<p>Defines a property on the normalized schema, which is used at time of instance construction</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@defineProperty</span>   : <span class="hljs-function"><span class="hljs-params">(propName, propConfig)</span> -&gt;</span>
      normalizedSchema[propName] = Scheming.normalizePropertyConfig(propConfig, propName)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="defineproperties">defineProperties</h3>
<p>Convenience method for defining properties in bulk</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@defineProperties</span> : <span class="hljs-function"><span class="hljs-params">(config)</span> -&gt;</span>
      <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">of</span> config
        <span class="hljs-property">@defineProperty</span> k, v</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="getproperties">getProperties</h3>
<p>returns a clone of the normalized Schema</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@getProperties</span> :<span class="hljs-function"> -&gt;</span>
      <span class="hljs-keyword">return</span> _.cloneDeep normalizedSchema</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="getproperty">getProperty</h3>
<p>returns a clone of the normalized Schema property</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@getProperty</span> : <span class="hljs-function"><span class="hljs-params">(propName)</span> -&gt;</span>
      <span class="hljs-keyword">return</span> _.cloneDeep normalizedSchema[propName]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="eachproperty">eachProperty</h3>
<p>Iterates over each property name and configuration of the schema, invoking the provided callback</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@eachProperty</span> : <span class="hljs-function"><span class="hljs-params">(cb)</span> -&gt;</span>
      <span class="hljs-keyword">for</span> propName, propConfig <span class="hljs-keyword">of</span> normalizedSchema
        cb propName, _.cloneDeep propConfig</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="validate">validate</h3>
<p>Run validation on an instance of the schema</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@validate</span> : <span class="hljs-function"><span class="hljs-params">(instance)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create errors hash that will be returned on any validation failure.</p></div></div><div class="code"><div class="wrapper">      errors = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag validating state to prevent infinite loop in the case of circular references</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> instance._validating <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
      instance._validating = <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Factored code to push error messages onto the errors hash</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-function"><span class="hljs-title">pushError</span> = <span class="hljs-params">(key, err)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> _.isArray err
          <span class="hljs-keyword">return</span> pushError(key, e) <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> err
        <span class="hljs-keyword">if</span> !_.isString err
          err = <span class="hljs-string">'Validation error occurred.'</span>
        errors[key] ?= []
        errors[key].push err</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply validation rules</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">of</span> normalizedSchema
        {validate, required} = value</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Retrieve value. This will be affected by getters.</li>
</ul></div></div><div class="code"><div class="wrapper">        val = instance[key]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the field is required and not defined, push the error and be done</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> required &amp;&amp; !val?
          pushError key, <span class="hljs-string">"Field is required."</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Only run validation on fields that are defined</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> val?
          {type} = normalizedSchema[key]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Run each validator on the field value</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">for</span> validator <span class="hljs-keyword">in</span> validate
            err = <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Accept error strings that are returned, or errors that are thrown during processing</li>
</ul></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">try</span>
              err = validator.call(instance, val)
            <span class="hljs-keyword">catch</span> e
              <span class="hljs-keyword">if</span> e <span class="hljs-keyword">then</span> err = e.message</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If any validation errors are detected, push them</li>
</ul></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span> pushError key, err</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Additionally, if the property is a nested schema, run its validation</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> type.string == <span class="hljs-string">'schema'</span>
            childErrors = type.childType.validate.call(instance, val)
            <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">of</span> childErrors</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>The key on the errors hash should be the path to the field that had a validation error</li>
</ul></div></div><div class="code"><div class="wrapper">              pushError <span class="hljs-string">"<span class="hljs-subst">#{key}</span>.<span class="hljs-subst">#{k}</span>"</span>, v</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the property is an array of schemas, run validation on each member of the array</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> type.string == <span class="hljs-string">'array'</span> &amp;&amp; type.childType.string == <span class="hljs-string">'schema'</span>
            <span class="hljs-keyword">for</span> member, i <span class="hljs-keyword">in</span> val
              childErrors = type.childType.childType.validate.call(instance, member)
              <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">of</span> childErrors</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Again, the key on the errors hash should be the path to the field that had a validation error</li>
</ul></div></div><div class="code"><div class="wrapper">                pushError <span class="hljs-string">"<span class="hljs-subst">#{key}</span>[<span class="hljs-subst">#{i}</span>].<span class="hljs-subst">#{k}</span>"</span>, v</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unset flag, indicating validation is complete</p></div></div><div class="code"><div class="wrapper">      instance._validating = <span class="hljs-literal">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return null if no validation errros ocurred</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> _.size(errors) == <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> errors</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="constructor">constructor</h3>
<p>Constructor that builds instances of the Schema</p></div></div><div class="code"><div class="wrapper">    constructor       : <span class="hljs-function"><span class="hljs-params">(model)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>turn <code>this</code> into a Schema instance</p></div></div><div class="code"><div class="wrapper">      instanceFactory(@, normalizedSchema, opts)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finally, initialize the instance with the model passed to the constructor</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> propName, value <span class="hljs-keyword">of</span> model
        @[propName] = value</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="change-manager">Change Manager</h3>
<p>Internal Change Manager class, responsible for queueing and resolving change event propagation for watches</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeManager</span></span>

  constructor :<span class="hljs-function"> -&gt;</span>
    <span class="hljs-property">@changes</span> = {}
    <span class="hljs-property">@internalChangeQueue</span> = []
    <span class="hljs-property">@timeout</span> = <span class="hljs-literal">null</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Registers changes that have occurred on an instance by instance id, holding a reference to the original value</p></div></div><div class="code"><div class="wrapper">  queueChanges : <span class="hljs-function"><span class="hljs-params">(id, propName, oldVal, fireWatchers)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if there are no changes yet queued for the insance, add to the changes hash by id</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> !_.has <span class="hljs-property">@changes</span>, id
      <span class="hljs-property">@changes</span>[id] ?= {changedProps : {}, fireWatchers}
      <span class="hljs-property">@internalChangeQueue</span>.push id
    {changedProps} = <span class="hljs-property">@changes</span>[id]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>for each changed property, track the original value of the property if it has not already been capturechangedPropsd.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> propName &amp;&amp; !_.has changedProps, propName
      changedProps[propName] = oldVal
      <span class="hljs-property">@internalChangeQueue</span>.push id</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set a timeout of zero to push the resolution step onto the event queue, once the thread has been released from
a synchronous block of changes</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@timeout</span> ?= setTimeout <span class="hljs-property">@resolve</span>, <span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>reset the the change manager to a pristine state</p></div></div><div class="code"><div class="wrapper">  reset :<span class="hljs-function"> -&gt;</span>
    <span class="hljs-property">@changes</span> = {}
    <span class="hljs-property">@internalChangeQueue</span> = []
    <span class="hljs-property">@timeout</span> = <span class="hljs-literal">null</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>resolves queued changes, firing watchers on instances that have changed</p></div></div><div class="code"><div class="wrapper">  resolve :<span class="hljs-function"> =&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>clear timeout to ensure to guarantee resolve is not called more than once.</p></div></div><div class="code"><div class="wrapper">    clearTimeout <span class="hljs-property">@timeout</span>

    i = <span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>fire internal watches as many times as necessary to to make sure all changes propagate from all child -&gt; parent
schema instances</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">while</span> <span class="hljs-property">@internalChangeQueue</span>.length
      i++</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>track iteration count and throw an error after some limit to prevent infinite loops</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> Scheming.ITERATION_LIMIT &gt; <span class="hljs-number">0</span> &amp;&amp; i &gt; Scheming.ITERATION_LIMIT
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Aborting change propagation after <span class="hljs-subst">#{Scheming.ITERATION_LIMIT}</span> cycles. If you have very deeply nested schemas you may consider raising the ITERATION_LIMIT configuration."</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A single id may have been pushed to the change queue many times, to take a unique list of ids.</p></div></div><div class="code"><div class="wrapper">      internalChanges = _.unique <span class="hljs-property">@internalChangeQueue</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Immediately reset the state of the change queue</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-property">@internalChangeQueue</span> = []</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fire internal watchers on all instances that have changed. This will cause the change event to propagate to
any parent schemas, whose changes will populate <code>@internalChangeQueue</code></p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> id <span class="hljs-keyword">in</span> internalChanges
        {changedProps, fireWatchers} = <span class="hljs-property">@changes</span>[id]
        fireWatchers changedProps, <span class="hljs-string">'internal'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Once internal watches have fired without causing a change on a parent schema instance, there are no more changes
to propagate. At this point all changes on each instance have been aggregated into a single change set. Now
fire all external watchers on each instance.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> id <span class="hljs-keyword">of</span> <span class="hljs-property">@changes</span>
      {changedProps, fireWatchers} = <span class="hljs-property">@changes</span>[id]

      fireWatchers changedProps, <span class="hljs-string">'external'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finally reset state to begin capturing next set of changes</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@reset</span>()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set up global change manager that will be consumed by all schema instances</p></div></div><div class="code"><div class="wrapper">cm = <span class="hljs-keyword">new</span> ChangeManager</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Configuration for limiting number of iterations</p></div></div><div class="code"><div class="wrapper">Scheming.ITERATION_LIMIT = <span class="hljs-number">100</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Synchronously cause the change manager resolve. Should be used for testing ONLY, to avoid having to write
asynchronous tests.</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">_flush</span> = -&gt;</span>
  cm.resolve()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="instance">Instance</h2>
<p>Factory method that builds accepts an object and turns it into a Schema instance</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-title">instanceFactory</span> = <span class="hljs-params">(instance, normalizedSchema, opts)</span>-&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>data hash wrapped in closure, keeps actual data members private</p></div></div><div class="code"><div class="wrapper">  data = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>private watchers array. External watches - those set by consuming client code - are tracked separately from
internal watches - those to watch change propagation on nested schemas</p></div></div><div class="code"><div class="wrapper">  watchers =
    internal : []
    external : []</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The unwatch functions from internal watches</p></div></div><div class="code"><div class="wrapper">  unwatchers = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set an id on each instance that is not exposed, is used internally only for change management</p></div></div><div class="code"><div class="wrapper">  id = uuid()

  {strict, seal} = opts</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="property-setter">Property Setter</h3></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-title">set</span> = <span class="hljs-params">(propName, val)</span> -&gt;</span>
    prevVal = data[propName]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if the property is not a part of the schema, simply set it on the instance.
if the seal option is enabled this will fail silently, otherwise it will allow for arbitrary properties</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> !normalizedSchema[propName]
      <span class="hljs-keyword">return</span> instance[propName] = val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>retrieve the type, getter, and setter from the normalized field config</p></div></div><div class="code"><div class="wrapper">    {type, setter} = normalizedSchema[propName]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If a property is set to undefined, do not type cast or run through setter.
You should always be able to clear a property.</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> val <span class="hljs-keyword">is</span> <span class="hljs-literal">undefined</span>
      data[propName] = val
    <span class="hljs-keyword">else</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If value is not undefined, run through type identifier to determine if it is the correct type</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> !type.identifier(val)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If not and strict mode is enabled, throw an error</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> strict <span class="hljs-keyword">then</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error assigning <span class="hljs-subst">#{val}</span> to <span class="hljs-subst">#{propName}</span>. Value is not of type <span class="hljs-subst">#{type.string}</span>"</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Otherwise, use parser to cast to the correct type</li>
</ul></div></div><div class="code"><div class="wrapper">        val = type.parser val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the property type is of array, perform parsing on child members.</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> type.string == NESTED_TYPES.Array.string
        val = type.childParser val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If a setter is defined, run the value through setter</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> setter
        val = setter val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Assign to the data hash</li>
</ul></div></div><div class="code"><div class="wrapper">      data[propName] = val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the value being assigned is of type schema, we need to listen for changes to propagate</li>
</ul></div></div><div class="code"><div class="wrapper">      watchForPropagation propName, val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Finally, check if the value has changed and queue up for instance watches</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> !type.equals prevVal, val
        cm.queueChanges id, propName, prevVal, fireWatchers</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="property-getter">Property Getter</h3></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-title">get</span> = <span class="hljs-params">(propName)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>retrieve the type, getter, and setter from the normalized field config</p></div></div><div class="code"><div class="wrapper">    {getter} = normalizedSchema[propName]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Retrieve data value from the hash</li>
</ul></div></div><div class="code"><div class="wrapper">    val = data[propName]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If value is not defined, immediately return it.</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> val <span class="hljs-keyword">is</span> <span class="hljs-literal">undefined</span>
      <span class="hljs-keyword">return</span> val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If getter is defined, run value through getter</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> getter
      val = getter val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Finally, return the value</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">return</span> val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Adds a watcher to the instance</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-title">addWatcher</span> = <span class="hljs-params">(properties, cb, opts)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>properties and opts arguments are optional</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> _.isFunction properties
      opts = cb
      cb = properties</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if no properties are specified, the watcher is registered to watch all properties of the object</p></div></div><div class="code"><div class="wrapper">      properties = _.keys normalizedSchema</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>unless specified, a watch is assumed to be external. Clinet code should not set watches as internal!
Behavior is undefined.</p></div></div><div class="code"><div class="wrapper">    opts ?= {}
    opts.internal ?= <span class="hljs-literal">false</span>

    target = <span class="hljs-keyword">if</span> opts.internal <span class="hljs-keyword">then</span> <span class="hljs-string">'internal'</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'external'</span>

    <span class="hljs-keyword">if</span> !_.isFunction cb
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">'A watch must be provided with a callback function.'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cast the properties to an array. A watch can support one or more property names.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> properties &amp;&amp; !_.isArray properties
      properties = [properties]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Throw an error if client code attempts to set a watch on a property that is not defined as part of the schema.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> propName <span class="hljs-keyword">in</span> properties
      <span class="hljs-keyword">if</span> !_.has normalizedSchema, propName
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Cannot set watch on <span class="hljs-subst">#{propName}</span>, property is not defined in schema."</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Register the watcher on the correct internal or external watchers array. Flag new watchers with <code>first</code> so that
they will get called on the first change loop, regardless of whether the watch properties have changed.</p></div></div><div class="code"><div class="wrapper">    watcher = {properties, cb, first : <span class="hljs-literal">true</span>}
    watchers[target].push watcher</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Queue a change event on the change manager.</p></div></div><div class="code"><div class="wrapper">    cm.queueChanges id, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, fireWatchers</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return an unwatch function</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">return</span><span class="hljs-function"> -&gt;</span>
      removeWatcher watcher, target</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove a watch listener from the appropraite watchers array</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-title">removeWatcher</span> = <span class="hljs-params">(watcher, target)</span> -&gt;</span>
    _.remove watchers[target], watcher</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function is called on value assignment</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-title">watchForPropagation</span> = <span class="hljs-params">(propName, val)</span> -&gt;</span>
    {type} = normalizedSchema[propName]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the assigned property is of type schema, we need to listen for changes on the child instance to propagate
changes to this instance</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> type.string == NESTED_TYPES.Schema.string</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there was a watcher from the previously assigned value, stop listening.</p></div></div><div class="code"><div class="wrapper">      unwatchers[propName]?()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Watch the new value for changes and propagate this changes to this instance. Flag the watch as internal.</p></div></div><div class="code"><div class="wrapper">      unwatchers[propName] = val.watch <span class="hljs-function"><span class="hljs-params">(newVal, oldVal)</span>-&gt;</span>
        cm.queueChanges id, propName, oldVal, fireWatchers

      , internal : <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the assigned property is an array of type schema, set a watch on each array memeber.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> type.string == NESTED_TYPES.Array.string <span class="hljs-keyword">and</span> type.childType.string == NESTED_TYPES.Schema.string</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there were watchers on the previous array members, clear those listeners.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> unwatcher <span class="hljs-keyword">in</span> (unwatchers[propName] || [])
        unwatcher()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>reset the unwatchers array</p></div></div><div class="code"><div class="wrapper">      unwatchers[propName] = []</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set a new watch on each array member to propagate changes to this instance. Flag the watch as internal.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> schema <span class="hljs-keyword">in</span> val
        unwatchers[propName].push schema.watch <span class="hljs-function"><span class="hljs-params">(newVal, oldVal)</span>-&gt;</span>
          cm.queueChanges id, propName, oldVal, fireWatchers
        , internal : <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a change set, fires all watchers that are watching one or more of the changed properties</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-title">fireWatchers</span> = <span class="hljs-params">(queuedChanges, target=<span class="hljs-string">'external'</span>)</span> -&gt;</span>
    triggeringProperties = _.keys queuedChanges</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Retrieves the previous value for a property, pulling from queued changes if present, otherwise retreiving
current value - i.e. no change.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-title">getPrevVal</span> = <span class="hljs-params">(propName)</span> -&gt;</span>
      <span class="hljs-keyword">if</span> _.has queuedChanges, propName
        <span class="hljs-keyword">return</span> queuedChanges[propName]
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> instance[propName]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>for each registered watcher</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> watcher <span class="hljs-keyword">in</span> watchers[target]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>That watcher should fire if it is new, or if it is watching one or more of the changed properties</p></div></div><div class="code"><div class="wrapper">      shouldFire = watcher.first || (_.intersection(triggeringProperties, watcher.properties).length &gt; <span class="hljs-number">0</span>)
      watcher.first = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">if</span> shouldFire
        newVals = {}
        oldVals = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>build the hash of new / old values</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">for</span> propName <span class="hljs-keyword">in</span> watcher.properties
          newVals[propName] = instance[propName]
          oldVals[propName] = getPrevVal(propName)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if the watcher is set against a single property, invoke the callback with the raw new / old values</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> watcher.properties.length == <span class="hljs-number">1</span>
          propName = watcher.properties[<span class="hljs-number">0</span>]
          newVals = newVals[propName]
          oldVals = oldVals[propName]

        watcher.cb newVals, oldVals</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="watch">watch</h3>
<p>Watches an instance for changes to one or more properties</p></div></div><div class="code"><div class="wrapper">  Object.defineProperty instance, <span class="hljs-string">'watch'</span>,
    configurable : <span class="hljs-literal">false</span>
    enumerable : <span class="hljs-literal">false</span>
    writable : <span class="hljs-literal">false</span>
    value : <span class="hljs-function"><span class="hljs-params">(properties, cb, opts)</span> -&gt;</span> addWatcher properties, cb, opts</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define a validating flag, which is used to prevent infinite loops on validation of circular references</p></div></div><div class="code"><div class="wrapper">  Object.defineProperty instance, <span class="hljs-string">'_validating'</span>,
    configurable : <span class="hljs-literal">false</span>
    enumerable : <span class="hljs-literal">false</span>
    writable : <span class="hljs-literal">true</span>
    value : <span class="hljs-literal">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="constructor">constructor</h3>
<p>for each property of the normalized schema</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">for</span> propName, propConfig <span class="hljs-keyword">of</span> normalizedSchema
    <span class="hljs-keyword">do</span> <span class="hljs-function"><span class="hljs-params">(propName, propConfig)</span> =&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>define an enumerable property on the instance that is not configurable
user get and set to manage getters, setters, and type parsing</p></div></div><div class="code"><div class="wrapper">      Object.defineProperty instance, propName,
        configurable : <span class="hljs-literal">false</span>
        enumerable   : <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>set</strong></p></div></div><div class="code"><div class="wrapper">        set          : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span> set propName, val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>get</strong></p></div></div><div class="code"><div class="wrapper">        get          :<span class="hljs-function"> -&gt;</span> get propName</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Once the property is configured, assign a default value. This ensures that default values are still
affected by type parsing and setters</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> propConfig.<span class="hljs-reserved">default</span> != <span class="hljs-literal">undefined</span>
        instance[propName] = propConfig.<span class="hljs-reserved">default</span>?() || propConfig.<span class="hljs-reserved">default</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If seal option is enabled, seal the instance, preventing addition of other properties besides those explicitly
defined by the Schema</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> seal
    Object.seal instance</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All done. Export onto the correct root.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">if</span> isNode
  <span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = Scheming
<span class="hljs-keyword">else</span>
  root.Scheming = Scheming</div></div></div></div></body></html>