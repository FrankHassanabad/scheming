<!DOCTYPE html><html lang="en"><head><title>Scheming</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="Scheming"><meta name="groc-project-path" content="src/Scheming.coffee"><meta name="groc-github-url" content="https://github.com/autoric/scheming"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/autoric/scheming/blob/master/src/Scheming.coffee">src/Scheming.coffee</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="annotated-source">Annotated Source</h1></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support node.js or browser environments</p></div></div><div class="code"><div class="wrapper">root = @

isNode = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> != <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> != <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Depends on lodash</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">if</span> isNode
  _ = <span class="hljs-built_in">require</span> <span class="hljs-string">'lodash'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Uuid generator for anonymous Schema ids</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-title">uuid</span> = -&gt;</span>
  now = Date.now()
  <span class="hljs-string">'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'</span>.replace <span class="hljs-regexp">/[xy]/g</span>, <span class="hljs-function"><span class="hljs-params">(c)</span> -&gt;</span>
    r = (now + Math.random() * <span class="hljs-number">16</span>) % <span class="hljs-number">16</span> | <span class="hljs-number">0</span>
    now = Math.floor now / <span class="hljs-number">16</span>
    ((<span class="hljs-keyword">if</span> c <span class="hljs-keyword">is</span> <span class="hljs-string">"x"</span> <span class="hljs-keyword">then</span> r <span class="hljs-keyword">else</span> (r &amp; <span class="hljs-number">0x7</span> | <span class="hljs-number">0x8</span>))).toString <span class="hljs-number">16</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="scheming">Scheming</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="default-options">DEFAULT_OPTIONS</h3>
<p>Default options for <code>Schema.create</code></p></div></div><div class="code"><div class="wrapper">DEFAULT_OPTIONS =
  seal   : <span class="hljs-literal">false</span>
  strict : <span class="hljs-literal">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="types">TYPES</h3>
<p>  Scheming exports the default types that it uses for parsing schemas. You can extend with custom types, or
  override the identifier / parser functions of the default types. A custom type should provide:</p>
<ul>
<li>ctor (optional) - Used in schema definitions to declare a type. <code>Scheming.create name : String</code></li>
<li>string - Used in schema definitions to declare a type. <code>Scheming.create name : &#39;string&#39;</code></li>
<li>identifier - Function, returns true or false. Determines whether a value needs to be parsed.</li>
<li>parser - Function, parses a value into the type.</li>
</ul></div></div><div class="code"><div class="wrapper">TYPES =
  String  :
    ctor       : String
    string     : <span class="hljs-string">'string'</span>
    identifier : _.isString
    parser     : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      <span class="hljs-string">''</span> + val
  Number  :
    ctor       : Number
    string     : <span class="hljs-string">'number'</span>
    identifier : _.isNumber
    parser     : parseFloat
  Integer :
    string     : <span class="hljs-string">'integer'</span>
    identifier : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      _.isNumber(val) &amp;&amp; val % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>
    parser     : parseInt
  Date    :
    ctor       : Date
    string     : <span class="hljs-string">'date'</span>
    identifier : _.isDate
    parser     : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      <span class="hljs-keyword">new</span> Date val
  Boolean :
    ctor       : Boolean
    string     : <span class="hljs-string">'boolean'</span>
    identifier : _.isBoolean
    parser     : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      !!val
  Mixed   :
    ctor       : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
      val
    string     : <span class="hljs-string">'*'</span>
    identifier :<span class="hljs-function"> -&gt;</span>
      <span class="hljs-literal">true</span>
    parser     : _.identity</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="nested-types">NESTED_TYPES</h3>
<p>  Special type definitions for nested types. Used to identify and parse nested Arrays and Schemas.
  Should not be extended or overridden.</p></div></div><div class="code"><div class="wrapper">NESTED_TYPES =
  Array  :
    ctor        : Array
    string      : <span class="hljs-string">'array'</span>
    identifier  : _.isArray
    parser      : _.toArray
    childType   : <span class="hljs-literal">null</span>
    childParser : <span class="hljs-literal">null</span>
  Schema :
    ctor       : Object
    string     : <span class="hljs-string">'schema'</span>
    identifier : <span class="hljs-literal">null</span>
    parser     : <span class="hljs-literal">null</span>
    childType  : <span class="hljs-literal">null</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used internally to resolve a type declaration to its primitive type.
Matches a primitive type if it is...</p>
<ul>
<li>a reference to the object straight from the <code>Schema.TYPES</code> object</li>
<li>a reference to the <code>ctor</code></li>
<li>a match with the type <code>string</code> (case insensitive)</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-title">getPrimitiveTypeOf</span> = <span class="hljs-params">(type)</span> -&gt;</span>
  <span class="hljs-keyword">for</span> k, TYPE <span class="hljs-keyword">of</span> TYPES
    <span class="hljs-keyword">if</span> type == TYPE <span class="hljs-keyword">or</span>
        (TYPE.ctor &amp;&amp; type == TYPE.ctor) <span class="hljs-keyword">or</span>
        type?.toLowerCase?() == TYPE.string

      <span class="hljs-keyword">return</span> TYPE

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Expose TYPES and DEFAULT_OPTIONS for extension and overriding</p></div></div><div class="code"><div class="wrapper">Scheming = {TYPES, NESTED_TYPES, DEFAULT_OPTIONS}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="resolvetype">resolveType</h3>
<p>Resolves a type declaration to a primitive or nested type. Used internally when normalizing a schema.</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">resolveType</span> = <span class="hljs-params">(typeDef)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Attempt to resolve the type declaration to a primitive type</li>
</ul></div></div><div class="code"><div class="wrapper">  type = getPrimitiveTypeOf typeDef

  <span class="hljs-keyword">if</span> !type?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the type definition is an array <code>[]</code></li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> _.isArray typeDef</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Set the type to a clone of the array NESTED_TYPE</li>
</ul></div></div><div class="code"><div class="wrapper">      type = _.cloneDeep NESTED_TYPES.Array</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Recurse to resolve childType of array members</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> typeDef.length
        childType = Scheming.resolveType(typeDef[<span class="hljs-number">0</span>])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Throw an error if type is not explicitly declared</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> !childType <span class="hljs-keyword">then</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving type of array value <span class="hljs-subst">#{typeDef}</span>"</span>

      type.childType = childType</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Write parser for child members of the array</li>
</ul></div></div><div class="code"><div class="wrapper">      type.<span class="hljs-function"><span class="hljs-title">childParser</span> = <span class="hljs-params">(val)</span> -&gt;</span>
        <span class="hljs-keyword">for</span> index, member <span class="hljs-keyword">of</span> val
          <span class="hljs-keyword">if</span> !childType.identifier(member)
            val[index] = childType.parser(member)

        <span class="hljs-keyword">return</span> val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function that builds identifier and parser for nested schema types. Needs to be factored out
because nested schemas may be resolved lazily at a later time</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-title">resolveSchemaType</span> = <span class="hljs-params">(type, childType)</span> -&gt;</span>
      type.childType = childType
      type.<span class="hljs-function"><span class="hljs-title">identifier</span> = <span class="hljs-params">(val)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> val <span class="hljs-keyword">instanceof</span> childType
      type.<span class="hljs-function"><span class="hljs-title">parser</span> = <span class="hljs-params">(val)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> childType(val)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the type definition is an object <code>{}</code><ul>
<li>Create a new Schema from the object</li>
<li>Treat the field as a nested Schema</li>
<li>Set identifier and parser functions immediately</li>
</ul>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> _.isPlainObject typeDef
      type = _.cloneDeep NESTED_TYPES.Schema
      childType = Scheming.create typeDef
      resolveSchemaType type, childType</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the type definition is a reference to a Schema constructor<ul>
<li>Treat the field as a nested Schema</li>
<li>Set identifier and parser functions immediately</li>
</ul>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> _.isFunction(typeDef) &amp;&amp; typeDef.__schemaId
      type = _.cloneDeep NESTED_TYPES.Schema
      childType = typeDef
      resolveSchemaType type, childType</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the type definition is a string that begins with Schema:, such as <code>&#39;Schema:Car&#39;</code><ul>
<li>It is assumed that the field is a reference to a nested Schema that will be registered with the name Car,
but may not be registered yet</li>
<li>The Schema is not resolved immediately</li>
<li>The parser and identifier functions are written as wrappers, so that the first time they are invoked the Schema
will be looked up at that time via <code>Scheming.get</code>, and real identifier and parser are set at that time.</li>
<li>If the registered Schema cannot be resolved, throw an error.</li>
</ul>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> _.isString(typeDef) &amp;&amp; typeDef[..<span class="hljs-number">.7</span>] == <span class="hljs-string">'Schema:'</span>
      type = _.cloneDeep NESTED_TYPES.Schema
      childType = typeDef[<span class="hljs-number">7.</span>.]
      <span class="hljs-keyword">for</span> fn <span class="hljs-keyword">in</span> [<span class="hljs-string">'identifier'</span>, <span class="hljs-string">'parser'</span>]
        <span class="hljs-keyword">do</span> <span class="hljs-function"><span class="hljs-params">(fn)</span> -&gt;</span>
          type[fn] = <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span>
            childType = Scheming.get childType
            <span class="hljs-keyword">if</span> !childType
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{typeDef}</span> on lazy initialization"</span>
            resolveSchemaType type, childType

            <span class="hljs-keyword">return</span> type[fn] val

  <span class="hljs-keyword">return</span> type || <span class="hljs-literal">null</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="normalizepropertyconfig">normalizePropertyConfig</h3>
<p>  Normalizes a field declaration on a schema to capture type, default value, setter, getter, and validation.
  Used internally when a schema is created to build a normalized schema definition.</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">normalizePropertyConfig</span> = <span class="hljs-params">(propConfig, propName = <span class="hljs-string">'field'</span>)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>initialize normalized property definition that we will return</p></div></div><div class="code"><div class="wrapper">  definition =
    type       : <span class="hljs-literal">null</span>
    <span class="hljs-reserved">default</span>    : <span class="hljs-literal">null</span>
    getter     : <span class="hljs-literal">null</span>
    setter     : <span class="hljs-literal">null</span>
    validators : <span class="hljs-literal">null</span>
    required   : <span class="hljs-literal">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if property configuration is not an object with a type key, assume that
the configuration value is just the property type</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> !(_.isPlainObject(propConfig) &amp;&amp; propConfig.type?)
    propConfig = {type : propConfig}

  {type, getter, setter, validate, required} = propConfig</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function throws errors on any bad configuration, attempting to fail fast.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Throw an error if type is not defined. Type must always be explicitly declared. Untyped fields
must explicitly declared as Schema.TYPES.Mixed</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> !type?
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{propName}</span>. Schema type must be defined."</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Throw an error if getter is not a function</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> getter? &amp;&amp; !_.isFunction getter
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{propName}</span>. Schema getter must be a function."</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Throw an error if setter is not a function</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> setter? &amp;&amp; !_.isFunction setter
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{propName}</span>. Schema setter must be a function."</span>


  validate ?= []</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If validate is a single function, transform to an array with one member</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> !_.isArray(validate)
    validate = [validate]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Check that all validators are a function, throw an error if it is not.</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">for</span> fn <span class="hljs-keyword">in</span> validate
    <span class="hljs-keyword">if</span> !_.isFunction fn
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{propName}</span>. Schema validate must be a function or array of functions."</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Resolve the declared type</li>
</ul></div></div><div class="code"><div class="wrapper">  definition.type = Scheming.resolveType type</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If type could not be resolved, throw an error</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> !definition.type?
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error resolving <span class="hljs-subst">#{propName}</span>. Unrecognized type <span class="hljs-subst">#{type}</span>"</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>default</code> is a reserved word, so we can&#39;t do the nice clean denatured assignment</p></div></div><div class="code"><div class="wrapper">  definition.<span class="hljs-reserved">default</span> = propConfig.<span class="hljs-reserved">default</span>
  definition.getter = getter
  definition.setter = setter
  definition.validators = validate
  definition.required = required</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return a valid property configuration</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">return</span> definition</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Internal registry for schemas created by <code>Scheming.create</code>. Schemas are registered by their name, which is either
provided at time of creation, or generated as a uuid.</p></div></div><div class="code"><div class="wrapper">registry = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used internally as part of <code>Scheming.create</code>, do not need to expose registration outside of Schema creation.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-title">addToRegistry</span> = <span class="hljs-params">(key, value)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Throw an error on naming collisions</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> registry[key]
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Naming conflict encountered. Schema <span class="hljs-subst">#{key}</span> already exists"</span>
  registry[key] = value</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="get">get</h3>
<p>Retrieves a schema by registered name</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">get</span> = <span class="hljs-params">(name)</span> -&gt;</span>
  <span class="hljs-keyword">return</span> registry[name]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="reset">reset</h3>
<p>Resets the state of the Schema registry. Mainly exposed for testing, but could have use in production.</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">reset</span> = -&gt;</span>
  registry = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="create">create</h3>
<p>Creates a new Schema constructor</p></div></div><div class="code"><div class="wrapper">Scheming.<span class="hljs-function"><span class="hljs-title">create</span> = <span class="hljs-params">(args...)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the first argument is a string, then the Schema is being named &amp; registered. Otherwise, it is being
created anonymously, and we need to give it a uuid for registration.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> !_.isString(args[<span class="hljs-number">0</span>])
    args.unshift uuid()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get name, config, and options from the create arguments</p></div></div><div class="code"><div class="wrapper">  [name, schemaConfig, opts] = args</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set options, defaulting to the Scheming.DEFAULT_OPTIONS</p></div></div><div class="code"><div class="wrapper">  opts = _.defaults (opts || {}), DEFAULT_OPTIONS</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build a new Schema</p></div></div><div class="code"><div class="wrapper">  Schema = schemaFactory(name, opts)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define properties on the Schema based on the schema configuration</p></div></div><div class="code"><div class="wrapper">  Schema.defineProperties schemaConfig</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Register the new Schema by the name provided or generated</p></div></div><div class="code"><div class="wrapper">  addToRegistry name, Schema

  <span class="hljs-keyword">return</span> Schema</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="schema">Schema</h2>
<p>Factory method that builds Schema constructors</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-title">schemaFactory</span> = <span class="hljs-params">(name, opts)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Normalized Schema is captured in closure</p></div></div><div class="code"><div class="wrapper">  normalizedSchema = {}

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Schema</span></span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>__schemaId property references the schema name and identifies Schema constructors from any other function</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@__schemaId</span>       : name</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="defineproperty">defineProperty</h3>
<p>Defines a property on the normalized schema, which is used at time of instance construction</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@defineProperty</span>   : <span class="hljs-function"><span class="hljs-params">(propName, propConfig)</span> -&gt;</span>
      normalizedSchema[propName] = Scheming.normalizePropertyConfig(propConfig, propName)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="defineproperties">defineProperties</h3>
<p>Convenience method for defining properties in bulk</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@defineProperties</span> : <span class="hljs-function"><span class="hljs-params">(config)</span> -&gt;</span>
      <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">of</span> config
        <span class="hljs-property">@defineProperty</span> k, v</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="constructor">constructor</h3>
<p>Constructor that builds instances of the Schema</p></div></div><div class="code"><div class="wrapper">    constructor       : <span class="hljs-function"><span class="hljs-params">(model)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>turn <code>this</code> into a Schema instance</p></div></div><div class="code"><div class="wrapper">      instanceFactory(@, normalizedSchema, opts)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finally, initialize the instance with the model passed to the constructor</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">of</span> model
        @[key] = value</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="instance">Instance</h2>
<p>Factory method that builds accepts an object and turns it into a Schema instance</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-title">instanceFactory</span> = <span class="hljs-params">(instance, normalizedSchema, opts)</span>-&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>data hash wrapped in closure, keeps actual data members private</p></div></div><div class="code"><div class="wrapper">  data = {}

  {strict, seal} = opts</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="constructor">constructor</h3>
<p>for each property of the normalized schema</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">for</span> propName, propConfig <span class="hljs-keyword">of</span> normalizedSchema
    <span class="hljs-keyword">do</span> <span class="hljs-function"><span class="hljs-params">(propName, propConfig)</span> =&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>retrieve the type, getter, and setter from the normalized field config</p></div></div><div class="code"><div class="wrapper">      {type, getter, setter} = propConfig</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>define an enumerable property on the instance that is not configurable
user get and set to manage getters, setters, and type parsing</p></div></div><div class="code"><div class="wrapper">      Object.defineProperty instance, propName,
        configurable : <span class="hljs-literal">false</span>
        enumerable   : <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>set</strong></p></div></div><div class="code"><div class="wrapper">        set          : <span class="hljs-function"><span class="hljs-params">(val)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If a property is set to undefined, do not type cast or run through setter.
You should always be able to clear a property.</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> val <span class="hljs-keyword">is</span> <span class="hljs-literal">undefined</span>
            <span class="hljs-keyword">return</span> data[propName] = val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If value is not undefined, run through type identifier to determine if it is the correct type</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> !type.identifier(val)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If not and strict mode is enabled, throw an error</li>
</ul></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> strict <span class="hljs-keyword">then</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Error assigning <span class="hljs-subst">#{val}</span> to <span class="hljs-subst">#{propName}</span>. Value is not of type <span class="hljs-subst">#{type.string}</span>"</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Otherwise, use parser to cast to the correct type</li>
</ul></div></div><div class="code"><div class="wrapper">            val = type.parser val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If a setter is defined, run the value through setter</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> setter
            val = setter val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Finally, assign to the data hash</li>
</ul></div></div><div class="code"><div class="wrapper">          data[propName] = val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>get</strong></p></div></div><div class="code"><div class="wrapper">        get          :<span class="hljs-function"> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Retrieve data value from the hash</li>
</ul></div></div><div class="code"><div class="wrapper">          val = data[propName]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If value is not defined, immediately return it.</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> val <span class="hljs-keyword">is</span> <span class="hljs-literal">undefined</span>
            <span class="hljs-keyword">return</span> val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If getter is defined, run value through getter</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> getter
            val = getter val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the property type is of array, perform parsing on child members now. This is costly but necessary.
Because arrays can be mutated outside of assignment, we have no way to enforce parsing of child members
until retrieval.</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> type.string == NESTED_TYPES.Array.string
            val = type.childParser val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Finally, return the value</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">return</span> val</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Once the property is configured, assign a default value. This ensures that default values are still
affected by type parsing and setters</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> propConfig.<span class="hljs-reserved">default</span> != <span class="hljs-literal">undefined</span>
        instance[propName] = propConfig.<span class="hljs-reserved">default</span>?() || propConfig.<span class="hljs-reserved">default</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="validate">validate</h3>
<p>Define validate method on instance</p></div></div><div class="code"><div class="wrapper">  instance.<span class="hljs-function"><span class="hljs-title">validate</span> = -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create errors hash that will be returned on any validation failure.</p></div></div><div class="code"><div class="wrapper">    errors = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag validating state to prevent infinite loop in the case of circular references</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> <span class="hljs-property">@_validating</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    <span class="hljs-property">@_validating</span> = <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Factored code to push error messages onto the errors hash</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-title">pushError</span> = <span class="hljs-params">(key, err)</span> -&gt;</span>
      <span class="hljs-keyword">if</span> _.isArray err
        <span class="hljs-keyword">return</span> pushError(key, e) <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> err
      <span class="hljs-keyword">if</span> !_.isString err
        err = <span class="hljs-string">'Validation error occurred.'</span>
      errors[key] ?= []
      errors[key].push err</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply validation rules</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">of</span> normalizedSchema

        {validators, required} = value</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Retrieve value. This will be affected by getters.</li>
</ul></div></div><div class="code"><div class="wrapper">        val = @[key]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the field is required and not defined, push the error and be done</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> required &amp;&amp; !val?
          pushError key, <span class="hljs-string">"Field is required."</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Only run validation on fields that are defined</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> val?
          {type} = normalizedSchema[key]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Run each validator on the field value</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">for</span> validator <span class="hljs-keyword">in</span> validators
            err = <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Accept error strings that are returned, or errors that are thrown during processing</li>
</ul></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">try</span>
              err = validator(val)
            <span class="hljs-keyword">catch</span> e
              <span class="hljs-keyword">if</span> e <span class="hljs-keyword">then</span> err = e.message</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If any validation errors are detected, push them</li>
</ul></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span> pushError key, err</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Additionally, if the property is a nested schema, run its validation</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> type.string == <span class="hljs-string">'schema'</span>
            childErrors = val.validate()
            <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">of</span> childErrors</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>The key on the errors hash should be the path to the field that had a validation error</li>
</ul></div></div><div class="code"><div class="wrapper">              pushError <span class="hljs-string">"<span class="hljs-subst">#{key}</span>.<span class="hljs-subst">#{k}</span>"</span>, v</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If the property is an array of schemas, run validation on each member of the array</li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> type.string == <span class="hljs-string">'array'</span> &amp;&amp; type.childType.string == <span class="hljs-string">'schema'</span>
            <span class="hljs-keyword">for</span> member, i <span class="hljs-keyword">in</span> val
              childErrors = member.validate()
              <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">of</span> childErrors</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Again, the key on the errors hash should be the path to the field that had a validation error</li>
</ul></div></div><div class="code"><div class="wrapper">                pushError <span class="hljs-string">"<span class="hljs-subst">#{key}</span>[<span class="hljs-subst">#{i}</span>].<span class="hljs-subst">#{k}</span>"</span>, v</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unset flag, indicating validation is complete</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@_validating</span> = <span class="hljs-literal">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return null if no validation errros ocurred</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> _.size(errors) == <span class="hljs-number">0</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">return</span> errors</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If seal option is enabled, seal the instance, preventing addition of other properties besides those explicitly
defined by the Schema</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> seal
    Object.seal instance</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All done. Export onto the correct root.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">if</span> isNode
  <span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = Scheming
<span class="hljs-keyword">else</span>
  root.Scheming = Scheming</div></div></div></div></body></html>